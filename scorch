#!/bin/bash
#
# Copyright 2015 WebMarcIT Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# scorch
# 
# VARIABLE naming convention
# Variable names will use <prefix Hungarian Notation>_CamelCase
# b    boolean                  TRUE,1 | FALSE,0
# fn   function name            fn_function
# p    pointer
# str  string
# dir  the variable defines a directory
# file the variable defines a filename
#
# Ideas not yet implemented........
# <hn>_ext_<var name>     A variable that has been derived from running an external script or
#                         command that might change
# <hn>_Local_<var name>   Variable that is defined as local for the function it is used for
# <hn>_Global_<var name>  Global variable that can be used in plugins when adding tasks to a 
#                         scorch job
# <hn>_Job_<var name>     Variables that are used when the job is running. Used to protect
#                         GLOBAL variable pollution
# =============================================================================================
# History
# 1.0		marc		First running demo
# 1.1		marc		Reversed and improved fn_RunJobs
# 1.2       marc        Improved fn_ShowJobs2, pause feature
# 1.3       marc        Improved task list, began lock manager and task manager
# 1.4       marc        Further improvements to task list
# 1.5       marc        Jobs now use symbolic links
# 1.6       marc        Audit handling
#                       Failed job audit tracking
#                       Enterprise Feature (Developer:Debug)
# 1.7       marc        #15 log update
#                       #16 multi job update
#                       shell check updates
#                       trap updates
#                       Enterprise feature multi-parent rule enabled
# 1.8 150805 marc       Improvement to manager layout with dynamic column width
# Determine the program name and the running directory
typeset str_ProgramVersion="1.7"

typeset    str_ProgramName=$(basename "$0")
typeset            dir_Run=$(dirname "$0")
typeset           dir_Orig="$(pwd)/${dir_Run}"
typeset         fn_LogDate="date +${str_ProgramName}:%y%m%d-%H%M%S"

fn_BaseDir()
{
  # Taking a directory name as a parameter, output the full absolute path
  # It could be absolute or relative so check and clean out any <dir>/../<dir> additions
  # if ${1} starts "/"
  cd "${1}" && pwd || return 1
}

# The running directory will become the str_BaseDir and will be dependant on a relative or absolute path
typeset dir_Base=$(fn_BaseDir "${dir_Run}")

# Directory definitions
# =====================
typeset       dir_Etc=${dir_Base}/etc
typeset       dir_Var=${dir_Base}/var
typeset       dir_Log=${dir_Var}/log
typeset      dir_Lock=${dir_Var}/locks
typeset       dir_Tmp=${dir_Base}/tmp
typeset   dir_Plugins=${dir_Base}/plugins
typeset   str_Plugins=$(basename "${dir_Plugins}")
typeset dir_Functions=${dir_Base}/functions
typeset str_Functions=$(basename "${dir_Functions}")

# Job definitions
# ===============
typeset         dir_Job=${dir_Base}/jobs
typeset       int_Count=1
typeset        file_CSV=${dir_Log}/jobs.csv

typeset         dir_New=${dir_Job}/new
typeset     dir_Running=${dir_Job}/running
typeset      dir_Failed=${dir_Job}/failed
typeset   dir_Completed=${dir_Job}/completed
typeset    dir_Starting=${dir_Job}/starting
typeset      dir_Queued=${dir_Job}/queued
typeset  dir_Superseded=${dir_Job}/superseded
typeset     dir_Deleted=${dir_Job}/deleted 
typeset    dir_Archived=${dir_Job}/archived
typeset     dir_Pending=${dir_Job}/pending
typeset      dir_Active=${dir_Job}/active 
typeset      file_JobId=${dir_Var}/jobid

fn_ResetJobDefinitions()
{
         dir_New=${dir_Job}/new
     dir_Running=${dir_Job}/running
      dir_Failed=${dir_Job}/failed
   dir_Completed=${dir_Job}/completed
    dir_Starting=${dir_Job}/starting
      dir_Queued=${dir_Job}/queued
  dir_Superseded=${dir_Job}/superseded
     dir_Deleted=${dir_Job}/deleted 
    dir_Archived=${dir_Job}/archived
      dir_Active=${dir_Job}/active
      file_JobId=${dir_Var}/jobid
}

# Dispatcher definitions
# ======================
typeset int_DispatcherPID=0
typeset   int_DispatchMax=10
typeset      file_JobLock=${dir_Lock}/JobLock
typeset  file_DispatchLog=${dir_Log}/dispatch.log
typeset file_DispatchLock=${dir_Lock}/dispatch.lck

# Layout Option
typeset      int_MaxShown=30

# Job states
# ==========
#file_States=${dir_Var}/states
#[[ -r ${file_States} ]] || ( echo "No state file defined: \"${file_States}\"" && exit  )

typeset     file_ProgLog="${dir_Log}/${str_ProgramName}.log"


# Load Functions
# ==============
fn_LoadFunctions()
{
  # Load Functions from a directory based on a search criteria
  # $1 Directory
  # $2 Search string
  #   Next
  #   -d    dir
  #   -pre  pre search
  #   -post post search
  #typeset local dir_Directory="$(basename ${1})"
  typeset local dir_Directory="${1}"
  typeset local    str_Search="${2}"
  typeset local     b_Display="${3}"
  typeset local      b_Errors=
  typeset local  str_EachFile=
  [[ ${b_Display} ]] || printf "\nLoading %s\n" "${dir_Directory}"
  if [ -d "${dir_Directory}" ] ; then
    arr_Functions=$(find -L "${dir_Directory}" -name "${str_Search}*" | sed 's/ /\\ /g')
    for str_EachFile in ${arr_Functions} ; do
      if [ -r "${str_EachFile}" ] ; then
        [[ ${b_Display} ]] || printf "%15s" "${str_EachFile#${dir_Directory}/*${str_Search}}"

        # Bash the function file for errors before loading it
        bash "${str_EachFile}" && . "${str_EachFile}"
		if [[ $? = 0 ]] ; then
          [[ ${b_Display} ]] || printf "%10s\n" "OK"
        else
          printf "%10s\n" "ERROR" && b_Errors=1
        fi
      else
        echo "Cannot access <${str_EachFile}>"
      fi
    done
  else
    echo "$(pwd) ${dir_Directory} could not be found"
  fi

  [[ "${b_Errors}" -eq 1 ]] && echo "Check function files for errors like missing quotes, brackets or malformed syntax" && exit 1
}
readonly -f fn_LoadFunctions

typeset b_Help=
typeset b_Dispatcher=
typeset b_New=
typeset b_Start=
typeset b_Background=
typeset b_Install=
typeset file_Template=

# Check for argument list
# scorch can be run in several ways (create, file, dispatcher)
if [ $# -ne 0 ] ; then
  while [ $# -gt 0 ] ; do
    case "$1" in
      -h          ) b_Help=1 ;;
      -v          ) echo "${str_ProgramName}[${str_ProgramVersion}]" ; exit 0 ;;
      -dispatcher ) b_Dispatcher=1 ;;
      -new        ) b_New=1 ;;
	  -background ) b_Background=1 ;;
      -file       ) shift ; file_Template="$1" ;;
      -s          ) b_Start=1 ;;
      -p          ) shift ; dir_Plugins="$(fn_BaseDir "${1}")"   ;;
      # Not yet working	  -f          ) shift ; dir_Functions="$(fn_BaseDir ${1})"  ;;
      -j          ) shift ; dir_Job="$(fn_BaseDir "${1}")" ; fn_ResetJobDefinitions ;;
      -install    ) b_Install=1 ;;
    esac
    shift
  done
fi

fn_LoadFunctions "${dir_Functions}" "Scorch_" ${b_New}
if [[ ! -z $ENTERPRISE ]] ; then
  fn_LoadFunctions "${dir_Functions}" "ScorchE_"
  str_License="Enterprise"
else
  str_License="OpenScorch"
fi

fn_CheckSetUp
fn_CheckDispatcher

[[ ${b_Dispatcher} ]] && fn_Dispatcher

if [[ ${file_Template} ]] ; then
  [[ ! -r "${file_Template}" ]] &&  echo "Error: Cannot read template file ${file_Request}" && exit 1
  fn_NewJob "${file_Template}"
  exit 0
fi

fn_CreateFile "${file_CSV}"
[[ ${b_SetUp} ]] && printf "\nThis may be the first time you have run this. Check the issues above and try again." && mkdir "${dir_Tmp}" &&  exit 1

if [[ "${b_Background}" ]] ; then
  # ADD LOOP HERE FOR JOB CHECKS
  typeset local b_Finished=1
  echo "$(${fn_LogDate}) $(whoami) Running in background to complete queued jobs"
  while [[ "$(find ${dir_Starting} ${dir_Pending} ${dir_Queued} -type l -exec grep -l "str_Owner=$(whoami)" {} \;)" ]] ; do 
    fn_RunJobs
	sleep 60
  done
  fn_RunJobs # one more try just to mop up
else
  fn_SetLayout
  [ "${b_Help}" ] && fn_Help && exit 0
  [ "${b_New}" ] && fn_NewJob && exit 0

  fn_Manager
  fn_CheckOwnJobs
fi
fn_HouseKeeping

exit 0