#!/bin/bash
##
## Copyright 2016 WebMarcIT Ltd
##
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
##    http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
## scorch
##
## VARIABLE naming convention
## Variable names will use <prefix Hungarian Notation>_CamelCase
## b    boolean                  TRUE,1 | FALSE,0
## fn   function name            fn_function
## p    pointer
## str  string
## dir  the variable defines a directory
## file the variable defines a filename
###
## Ideas not yet implemented........
## <hn>_ext_<var name>     A variable that has been derived from running an external script or
##                         command that might change
## <hn>_Local_<var name>   Variable that is defined as local for the function it is used for
## <hn>_Global_<var name>  Global variable that can be used in plugins when adding tasks to a
##                         scorch job
## <hn>_Job_<var name>     Variables that are used when the job is running. Used to protect
##                         GLOBAL variable pollution
## =============================================================================================
## History
## 1.0       marc        First running demo
## 1.1       marc        Reversed and improved fn_RunJobs
## 1.2       marc        Improved fn_ShowJobs2, pause feature
## 1.3       marc        Improved task list, began lock manager and task manager
## 1.4       marc        Further improvements to task list
## 1.5       marc        Jobs now use symbolic links
## 1.6       marc        Audit handling
##                       Failed job audit tracking
##                       Enterprise Feature (Developer:Debug)
## 1.7       marc        #15 log update
##                       #16 multi job update
##                       shell check updates
##                       trap updates
##                       Enterprise feature multi-parent rule enabled
## 1.8  150805 marc      Improvement to manager layout with dynamic column width
## 1.9  150805 marc      Check for outstanding jobs on exit
## 1.10 150817 marc      Removed System as a key-pair
##      150904 marc      Updated comments
##                       Added upper flag to GetVar
##                       Toggle pause flag
## 1.11 151127 marc      Fixed issue with LOCK filename
##                       github#20 Tail feature added
##      151130 marc      github#13 Added tryTask option
## 1.12 151223 marc      Added fix in progress
##                       Cleaned up some code
## 1.13 160114 marc      Added preferences for SHOWMAX and REFRESH
## 1.14 160126 marc              Indicate Job Ownwer
##                       pauseTask added
##                       breakTask added
## 1.15 160211 marc      Protected header comment lines from stripping when creating openscorch
##                       GAWK and NAWK are both checked (note NAWK does not have upper/lower options)
##                       Improved "owner" check(g|n)awk command
##                       JobID changed to JobID.<program name>
## 1.16 160713 marc      Fixed job owner reporting
##                       Old active jobs recovered from archive
## 1.17 170922 marc      Added update notification to Context Menu
## 1.18 171015 marc      Formatting program and output. Improved %age call for disk space
##                       Added timer to running jobs
## 1.19 171018 marc      Added lower and upper options for GetVar
##                       working on breakTask internal for jobs
## 1.20 171204 marc      Trial python for showJobs
## 1.21dev 180207 marc   Fixing TASK for none running jobs
##                       Adding plugin manager
##                       dos2unix on showJobs.py
##                       Wait group improvements
##                       editor build git test
## 1.22 180424           Task display updates
## 1.22.1 180424  marc   Issue #28 resolved
## 1.23 180502           Completed list is showjobs.py reversed
## 1.24 180503    marc   Publish functions updated to include Python
## 1.25 180509    marc   Resume group tasks beta
## git config --global core.editor "'C:\Users\marc\Downloads\Sublime Text Build 3143 x64\sublime_text.exe' -multiInst -nosession"

## Determine the program name and the running directory
typeset str_ProgramVersion="1.25beta"
typeset    str_ProgramName="$(basename "$0")"
typeset            dir_Run="$(dirname "$0")"
typeset           dir_Orig="$(pwd)/${dir_Run}"
typeset     fn_FullLogDate="date +${str_ProgramName}:%y%m%d-%H%M%S"
typeset         fn_LogDate="date +%y%m%d-%H%M%S"
typeset           str_User=$(whoami)

typeset         file_Prefs=~/${str_ProgramName}.prefs
## User EDITOR preference
typeset         cmd_Editor="${EDITOR:-vi}"
echo "${COLUMNS}"

fn_BaseDir()
{
  ## Taking a directory name as a parameter, output the full absolute path
  ## It could be absolute or relative so check and clean out any <dir>/../<dir> additions
  ## if ${1} starts "/"
  [ -d "${1}" ] || return 1
  cd "${1}" && pwd || return 1
}

## The running directory will become the str_BaseDir and will be dependant on a relative or absolute path
typeset        dir_Base=$(fn_BaseDir "${dir_Run}")
typeset          str_OS=$(uname -o)

## Directory definitions
## =====================
typeset         dir_Etc="${dir_Base}/etc"
typeset         dir_Var="${dir_Base}/var"
typeset         dir_Log="${dir_Var}/log"
typeset        dir_Lock="${dir_Var}/locks"
typeset         dir_Tmp="${dir_Base}/tmp"
typeset         dir_Tmp="/dev/shm"
typeset     dir_Plugins="${dir_Base}/plugins"
typeset     str_Plugins="$(basename "${dir_Plugins}")"
typeset   dir_Functions="${dir_Base}/functions"
typeset      dir_Python="${dir_Base}/python"
typeset   str_Functions="$(basename "${dir_Functions}")"

## Job definitions
## ===============
typeset         dir_Job="${dir_Base}/jobs"
typeset       int_Count=1
typeset        file_CSV="${dir_Log}/jobs.csv"
typeset         dir_New="${dir_Job}/new"
typeset     dir_Running="${dir_Job}/running"
typeset      dir_Failed="${dir_Job}/failed"
typeset      dir_Fixing="${dir_Job}/fixing"
typeset   dir_Completed="${dir_Job}/completed"
typeset    dir_Starting="${dir_Job}/starting"
typeset      dir_Queued="${dir_Job}/queued"
typeset  dir_Superseded="${dir_Job}/superseded"
typeset     dir_Deleted="${dir_Job}/deleted"
typeset    dir_Archived="${dir_Job}/archived"
typeset     dir_Pending="${dir_Job}/pending"
typeset      dir_Active="${dir_Job}/active"
typeset      dir_Manual="${dir_Job}/manual"

##typeset      file_JobID="${dir_Var}/jobid"

typeset           b_Group=
typeset      b_Background=
typeset       int_SubTask=
typeset       str_SubTask=
typeset int_DispatchSleep=10
typeset           hex_MD5=

fn_ResetJobDefinitions()
{
         dir_New="${dir_Job}/new"
     dir_Running="${dir_Job}/running"
      dir_Failed="${dir_Job}/failed"
   dir_Completed="${dir_Job}/completed"
    dir_Starting="${dir_Job}/starting"
      dir_Queued="${dir_Job}/queued"
  dir_Superseded="${dir_Job}/superseded"
     dir_Deleted="${dir_Job}/deleted"
    dir_Archived="${dir_Job}/archived"
      dir_Active="${dir_Job}/active"
##      file_JobID="${dir_Var}/jobid"
}

## Dispatcher definitions
## ======================
typeset int_DispatcherPID=0
typeset   int_DispatchMax=10
typeset      file_JobLock="${dir_Lock}/JobLock"
typeset  file_DispatchLog="${dir_Log}/dispatch.log"
typeset file_DispatchLock="${dir_Lock}/dispatch.lck"

## Layout Option
## =============
typeset      int_MaxShown="${SHOWMAX:-30}"
typeset       int_Refresh="${REFRESH:-20}"
typeset          int_Tail="${TAIL:-25}"

## Job states
## ==========
##file_States=${dir_Var}/states
##[[ -r ${file_States} ]] || ( echo "No state file defined: \"${file_States}\"" && exit  )

## Program Log
## ===========
typeset      file_ProgLog="${dir_Log}/${str_ProgramName}.log"

## Authority
## =========
typeset str_Authority=
typeset       b_Power=0
typeset  b_Restricted=0

## Load Functions
## ==============
fn_LoadFunctions()
{
  ## Load Functions from a directory based on a search criteria
  ## $1 Directory
  ## $2 Search string
  ##   Next
  ##   -d    dir
  ##   -pre  pre search
  ##   -post post search
  ##typeset local dir_Directory="$(basename ${1})"
  typeset local dir_Directory="${1}"
  typeset local    str_Search="${2}"
  typeset local     b_Display="${3}"
  typeset local      b_Errors=
  typeset local  str_EachFile=
  ##[[ ${b_Display} ]] || printf "\nLoading %s\n" "${dir_Directory}"
  if [ -d "${dir_Directory}" ] ; then
        SAVEIFS=$IFS
    IFS=$(echo -en "\n\b")
    arr_Functions=$(find -L "${dir_Directory}" -name "${str_Search}*" | sed 's/ /\\ /g')
    arr_Functions=$(find -L "${dir_Directory}" -name "${str_Search}*")
    for str_EachFile in ${arr_Functions} ; do
      if [ -r "${str_EachFile}" ] ; then
        [[ ${b_Display} ]] || printf "%15s" "${str_EachFile#${dir_Directory}/*${str_Search}}"

        # Bash the function file for errors before loading it
        bash "${str_EachFile}" && . "${str_EachFile}"
        if [[ $? = 0 ]] ; then
          [[ ${b_Display} ]] || printf "%10s\n" "OK"
        else
          printf "%10s\n" "ERROR" && b_Errors=1
        fi
      else
        echo "Cannot access <${str_EachFile}>"
      fi
    done
    IFS=$SAVEIFS
  else
    :
        ##echo "$(pwd) ${dir_Directory} could not be found"
  fi

  [[ "${b_Errors}" -eq 1 ]] && echo "Check function files for errors like missing quotes, brackets or malformed syntax" && exit 1
}
readonly -f fn_LoadFunctions

fn_CheckLicense()
{
  echo "Checking license"
  b_Licence=1
  return 1
}

typeset b_Help=
typeset b_Dispatcher=
typeset b_New=
typeset b_Start=
typeset b_Background=
typeset b_Install=
typeset file_Template=
typeset str_Action=
typeset lst_GetVar=
typeset b_Interactice=1
typeset b_Sync=

## Check for argument list
## scorch can be run in several modes (install, new, file, dispatcher, manager and background)
if [ $# -ne 0 ] ; then
  while [ $# -gt 0 ] ; do
    case "$1" in

      -h          ) b_Help=1 ;;
      -v          ) echo "${str_ProgramName}[${str_ProgramVersion}]" ; exit 0 ;;

      ## API Mode
      -a          ) shift ; file_Template=$(mktemp) ; str_Action=$1 ; b_Interactice=0 ;;
      -o          ) shift ; [[ ! $lst_GetVar ]] && lst_GetVar=$1 || lst_GetVar="${lst_GetVar};$1" ;;
      -s          ) b_Start=1 ;;
      -sync       ) b_Sync=1 ;;
      -dispatcher ) b_Dispatcher=1 ;;

      ## Internal Mode
      -file       ) shift ; file_Template="$1" ; b_Interactice=0 ;;
      -new        ) b_New=1 ;;
      -background ) b_Background=1 ;;

      ## Development / Alternative Mode
      -p          ) shift ; dir_Plugins="$(fn_BaseDir "${1}")"   ;;
      -j          ) shift ; dir_Job="$(fn_BaseDir "${1}")" ; fn_ResetJobDefinitions ;;

      ## Install Mode
      -install    ) b_Install=1 ;;

      ## Not yet working          -f          ) shift ; dir_Functions="$(fn_BaseDir ${1})"  ;;
    esac
    shift
  done
fi




#HEADER
#RESERVED FOR LOADING OPENSCROCH - DO NOT REMOVE
fn_LoadFunctions "${dir_Functions}" "Scorch_" ${b_New}
echo $(fn_CheckLicense) && ENTERPRISE=1
if [[ ! -z $ENTERPRISE ]] ; then
  fn_LoadFunctions "${dir_Functions}" "ScorchE_"
  str_License="Enterprise"
else
  printf "\n\n Open Source License. Check out www.autoscorch.com for enterprise license details.\n\n Please wait..."
  sleep 2
  str_License="OpenScorch"
fi

# Area reserved for loading OPENSCORCH - Do not remove
#FOOTER
fn_CheckSetUp
fn_CheckAuth
fn_CheckDispatcher

[[ ${b_Dispatcher} ]] && fn_Dispatcher
if [[ ${str_Action} ]] ; then
  echo "Action:${str_Action}" > ${file_Template}
  echo "${lst_GetVar}" | tr ";" "\n" >> ${file_Template}
  cat ${file_Template}
fi

if [[ ${file_Template} ]] ; then
  [[ ! -r "${file_Template}" ]] &&  echo "Error: Cannot read template file ${file_Request}" && exit 1
  fn_NewJob "${file_Template}"
  if [[ ${b_Sync} ]] ; then
    b_Debug=1
    echo "waiting for ${str_JobName} to complete"
    set | grep SAFE
    sleep 10
  else
    exit 0
  fi
fi

fn_CreateFile "${file_CSV}"
[[ ${b_SetUp} ]] && printf "\nThis may be the first time you have run this. Check the issues above and try again." && mkdir "${dir_Tmp}" &&  exit 1

if [[ "${b_Background}" ]] ; then
  # ADD LOOP HERE FOR JOB CHECKS
  typeset local b_Finished=1
  echo "$(${fn_LogDate}) ${str_User} Running in background to complete queued jobs"
  while [[ "$(find ${dir_Starting} ${dir_Pending} ${dir_Queued} -type l -exec grep -l "str_Owner=${str_User}" {} \;)" ]] ; do
    fn_RunJobs
    sleep 60
  done
  fn_RunJobs # one more try just to mop up
else
  fn_SetLayout
  [ "${b_Help}" ] && fn_Help && exit 0
  [ "${b_New}" ] && fn_NewJob && exit 0

  fn_Manager
  fn_CheckOwnJobs
fi
fn_HouseKeeping


tput sgr0 2 >/dev/null
exit 0
