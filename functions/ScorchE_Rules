#
# Copyright 2016 WebMarcIT Ltd
#
# This is the propitiatory .....
fn_GetRequest()
{
  ## Receive the request from a file or interactively
  typeset local file_Template="${1:-}"
  typeset local str_Line=""
  typeset local int_GetCount=1

  ## global tmp file
  file_Request=${dir_Tmp}/${str_ProgramName}.$$.${int_GetCount}
  fn_CreateFile "${file_Request}"

  if [ ! -z "${file_Template}" ] ; then
    echo "$($fn_LogDate): Processing file:${file_Template}"
    while read -r str_Line ; do
	  str_ULine=$(echo ${str_Line} | tr [:lower:] [:upper:])
      [[ ${str_ULine} =~ ACTION ]] &&  (( int_GetCount+=1 )) && file_Request=${dir_Tmp}/${str_ProgramName}.$$.${int_GetCount}
      echo "${str_Line}" | grep ":" >> "${file_Request}"
    done < "${file_Template}"
  else
    printf "\n help <plugin>    at any time for additional parameters\n\n"
    printf " Please enter the request below.\n To complete the request is use a fullstop on a newline:\n (To quit type CANCEL)\n\n"

    while [[ "${str_Line}" != "." ]] ; do
      read -r str_Line
	  str_ULine=$(echo ${str_Line} | tr [:lower:] [:upper:])
##      if echo "${str_Line}" | grep -qi ACTION ; then
##        (( int_GetCount+=1 ))
##        file_Request=${dir_Tmp}/${str_ProgramName}.$$.${int_GetCount}
##      fi
      if [[  ${str_ULine} =~ HELP ]] ; then
        typeset local str_Help=${str_Line#help }
        if [[ "${str_Line}" ]] ; then
          echo "==SYSTEM============="
          declare -f fn_ExtractPairs | grep "GetVar -pattern"
          echo "==CUSTOM============="
          declare -f "SP_${str_Help}" | grep "GetVar "
          echo "==============="
        fi
      else
	    [[ ${str_ULine} =~ CANCEL ]] && rm ${dir_Tmp}/${str_ProgramName}.$$.[0-9]* && break
        [[ ${str_ULine} =~ ACTION ]] &&  (( int_GetCount+=1 )) && file_Request=${dir_Tmp}/${str_ProgramName}.$$.${int_GetCount}
        echo "${str_Line}" | grep ":" >> "${file_Request}"
      fi
    done
  fi
}
readonly -f fn_GetRequest

fn_ProcessRequest()
{
  typeset local int_JobCount=1
  typeset local int_FileCount=1

  fn_GetJobID
  
  for str_EachFile in ${dir_Tmp}/${str_ProgramName}.$$.* ; do
    [[ -e ${str_EachFile} ]] || break
    file_Request=${dir_Tmp}/${str_ProgramName}.$$.${int_FileCount}
    echo "${str_EachFile}"

    fn_ExtractPairs
  
    [[ "${b_Debug}" ]] && echo "Action: ${ACTION}"
    for ACTION in ${ACTION_LIST} ; do
      for ENVIRONMENT in ${ENVIRONMENT_LIST} ; do

        int_TaskCount=0
        if type -t "SP_${ACTION}" >/dev/null ; then
          fn_Call="SP_${ACTION}"
        else
          printf "\n\nCannot find a function called SP_${ACTION} or ${fn_Call}\n"
          fn_PressEnter
          return 0
        fi
        str_Call=${fn_Call#SP_}
		[[ ! -z "${LABEL}" ]]  && str_Label="${LABEL}" || str_Label="${ACTION}"
        file_Job="${dir_New}"/${str_JobPrefix}${TICKET}_${int_JobID}.${str_Label}.${int_JobCount}_${str_Call}_${ENVIRONMENT}_${RELEASE}
        if [[ ! -z "${PARENT_LIST}" ]] ; then
          for str_EachRule in ${PARENT_LIST} ; do
            echo "PARENT:${str_JobPrefix}${TICKET}_${int_JobID}.${str_EachRule}.*" >> "${dir_Active}/$(basename "${file_Job}")".rules
          done
        fi
        fn_JobHeader "${file_Job}"
        Task "echo AUDIT:START:\${str_StartTime}"

        echo "$(${fn_LogDate}) Plugin:${str_Call}" >> "${dir_Log}"/$(basename "${file_Job}").log
        eval "${fn_Call}"
        if [[ $? -ne 0 ]] ; then
          echo "$(${fn_LogDate}) Error in plugin" >> "${dir_Log}"/$(basename "${file_Job}").log
          mv "${file_Job}" "${dir_Failed}"/.
          fn_PressEnter
          exit 1
        fi

        fn_JobFooter "${file_Job}"
        echo "$(${fn_LogDate}) Created by:$(whoami) Tasks[${int_TaskCount}]" >> "${dir_Log}"/$(basename "${file_Job}").log
        (( int_JobCount+=1 ))

        if [[ $(ls "${dir_Failed}"/"${str_JobPrefix}*_${ACTION}_${ENVIRONMENT}*" 2>/dev/null)  ]] ; then
           mv "${dir_Failed}"/"${str_JobPrefix}*_${ACTION}_${ENVIRONMENT}*" "${dir_Superseded}"/.
        fi
        [[ ${b_Start} ]] && mv "${file_Job}" "${dir_Queued}/." 
		
      done
    done
    (( int_FileCount++ ))
    rm "${file_Request}"
  done
}
readonly -f fn_ProcessRequest

fn_ShowRules()
{
  ## typeset local file_Job="${1}"
  echo ""
  [[ -r ${file_ActiveJob}.rules ]] && ( fn_ShowLine "-" "Rules" ; cat ${file_ActiveJob}.rules ; echo "" ) 
}
readonly -f fn_ShowRules

fnE_Rules()
{  
  fn_PressEnter
} 
readonly -f fnE_Rules

fnE_RulesMenu()
{
 ## printf "\n\n Rules menu "
  printf " ${dis_ULOn}A${dis_ULOff}mend rules |"
}
readonly -f fnE_RulesMenu

fnE_AmendRules()
{
  fn_ShowTop
  fn_ShowLine "-" "File details"
  echo ""
  ls -lL "${file_ActiveJob}"
  ls -lL "${file_Log}"
  echo ""
  fn_ShowRules
  fn_ShowLine "-" 

  printf "\n\n "
  printf " ${dis_ULOn}A${dis_ULOff}dd parent | ${dis_ULOn}D${dis_ULOff}elete rules  | e${dis_ULOn}X${dis_ULOff}it : "

  read -t 60 char_Choice

    case ${char_Choice} in

	  a | A ) fn_ShowJobs2 running starting pending queued new
               fn_ShowLine
               fn_GetAnswer
			   echo "PARENT:${arr_Jobs[${str_Answer}]}" >> ${file_ActiveJob}.rules ;;
	
	  d | D ) rm ${file_ActiveJob}.rules 
	          # if link to active job in pending mv job to queued 
			  ;; 

      ## Edit job
      x | X ) return 0 ;;
      *     ) return 0 ;;
    esac

}
readonly -f fnE_AmendRules

fn_ExtractPairs()
{
  GetVar -pattern "From"    -name FROM
  GetVar -pattern "Sent"    -name SENT
  GetVar -pattern "Action"  -name ACTION_LIST      -list
  GetVar -pattern "Release" -name RELEASE                -default "NO-REL"
  GetVar -pattern "Enviro"  -name ENVIRONMENT_LIST -list -default "NO-ENV"
  GetVar -pattern "Type"    -name TYPE                   -default ""
  GetVar -pattern "Ticket"  -name TICKET                 -default ""
  
  GetVar -pattern "Label"  -name LABEL                   -default ""
  GetVar -pattern "Parent" -name PARENT_LIST -list       -default ""
  
}
readonly -f fn_ExtractPairs

fn_CheckAuth()
{
  ## This function is stubbed for future enhancements
  ## The idea is that users will need to be allowed to use scorch as a reporting tool
  ## or be allowed access to certain systems/plugin directories

  ##  #Username  : [ full | <blank> ] : [ all | <comma seperated list of plugin dirs>]  
  ##     marc:full:all
  ##     root::all
  ##     user::demo

  echo "Authority given - stubbed"
}
readonly -f fn_CheckAuth