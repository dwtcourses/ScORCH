##
## Copyright 2016 WebMarcIT Ltd
##
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
##    http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##

## These functions manage the manager/view screen
## fn_Manager()
## fn_AdminFunctions()


fn_Manager()
{
  typeset local char_Choice=
  tput rmam
  hex_MD5=$(md5sum ${dir_Base}/${str_ProgramName} | cut -d" " -f1)
  while : ; do
    fn_ShowTop
    fn_ShowJobs superseded failed fixing new running starting pending queued completed
    fn_ShowLine "="
    fn_DisplayMOTD
    printf "\n${dis_Reset}"
    fn_ContextMenu


    read -n 1 -t ${int_Refresh} char_Choice

    case ${char_Choice} in
      ## Create a new job
      n | N ) "${dir_Base}"/${str_ProgramName} -new -p "${dir_Plugins}/." -j "${dir_Job}/." ; fn_SetLayout ;;

      ## View CSV
      c | C ) ${cmd_Editor} "${file_CSV}" ;;

      ## Job State transition
      d | D ) fn_Transition delete  ;;
      q | Q ) fn_CheckDispatcher ; fn_Transition queue   ;;
      r | R ) fn_CheckDispatcher ; fn_Transition resume  ;;
      u | U )                      fn_Transition unqueue ;;
      p | P )                      fn_Transition pause   ;;

      ## Misc
      m | M ) fn_EditMOTD           ;;
      t | T ) fn_ShowTasks          ;;
      l | L ) fn_LockManager        ;;
      x | X ) break ;;


      ## Releases
      [0-9] ) fn_CatchWord ${char_Choice} "number" ;;

      o | O ) 
         read -t ${int_Refresh} char_ChoiceExtra
         str_Choice="${char_Choice,,}${char_ChoiceExtra,,}"
         case ${str_Choice} in
            open       ) fnE_MkOpenScorch ;;
         esac  ;;

      e | E )
         read -t ${int_Refresh} char_ChoiceExtra
         str_Choice="${char_Choice,,}${char_ChoiceExtra,,}"
         case ${str_Choice} in
            enterprise ) fnE_MkEscorchtar ;;
         esac  ;;

      s | S )
         read -t ${int_Refresh} char_ChoiceExtra
         str_Choice="${char_Choice,,}${char_ChoiceExtra,,}"
         case ${str_Choice} in
            set )   fnE_Set ;;
         esac  ;;


      * ) fn_SetLayout ;;

    esac
	fn_RunJobs
  done
  tput smam
}
readonly -f fn_Manager

fn_ViewJob()
{
  typeset local file_Orig="$1"
  typeset local file_View="${file_Orig}.$$"
  cp "${file_Orig}" "${file_View}"
  ${cmd_Editor} "${file_View}"
  if ! diff "${file_Orig}" "${file_View}" ; then
    printf "\n\nWarning. Not in edit mode. Changes will not be saved.\n"
	  read -n 1 -p "Do you want to save your changes to /tmp? [y/n] " char_Answer
	  printf "\n\n"
	  if [[ "${char_Answer}" = "y" ]] || [[ "${char_Answer}" = "Y" ]] ; then
	    mv "${file_View}" /tmp/$(basename "${file_Orig}")
      fn_Audit "${file_Orig}" "saved an edited copy of job and saved a copy in /tmp"
    fi
	#fn_PressEnter
  fi
  [ -f "${file_View}" ] && rm -f "${file_View}"
}
readonly -f fn_ViewJob

fn_EditJob()
{
  typeset local file_Orig="$1"
  fn_CheckOwner "${file_Orig}"
  typeset local file_Edit="${file_Orig}.$$"
  cp "${file_Orig}" "${file_Edit}"
  ${cmd_Editor} "${file_Edit}"
  if ! diff "${file_Orig}" "${file_Edit}" ; then
	  mv "${file_Edit}" "${file_Orig}"
    fn_Audit "${file_Orig}" "edited job"
  fi
  [ -f "${file_Edit}" ] && rm -f "${file_Edit}"
}
readonly -f fn_EditJob

fn_Cancel()
{
  typeset local    file_Link="$1"
  typeset local str_JobState="$2"
  typeset local     file_Log="${dir_Log}/$(basename ${file_Link})".log

  fn_CheckOwner "${file_Link}"
  if [[ "${str_JobState}" = "running" ]] ; then
    echo kill job
    ps -fu ${str_User} | grep $(basename ${file_Link}) | grep -v bash | grep -v grep
    int_PID=$(ps -fu ${str_User} | grep $(basename ${file_Link}) | grep -v grep | awk -F" " '{print $2}')
    ps -fu ${str_User}
    pstree -p ${int_PID}
    echo ${int_PID} 
    printf "\n\n Killing Process with PID[${int_PID}]"
    # mv ${file_Link} ${dir_Failed}

   # kill ${int_PID}
    fn_PressEnter
  elif  [[ "${str_JobState}" = "failed"  ]] ; then
    fn_Audit "${file_Link}" "Cancelled at task:$(fn_GetResumePoint ${file_Log} ) "
    mv ${file_Link} ${dir_Completed}
    printf "\n\n Cancelled Job : ${file_Link}"
    fn_PressEnter
  else
    echo "Incorrect call"
  fi
  sleep 2
}

fn_AdminFunctions()
{
  typeset local char_Choice=${1}
  if [[ ${char_Choice} -gt 0 ]] && [[ ${char_Choice} -lt ${int_Count} ]] ; then

  ##if [[ ${char_Choice} -lt ${int_Count} ]] ; then

    typeset         str_JobState="${arr_States[${char_Choice}]}"
    typeset local       file_Job="${dir_Active}/${arr_Jobs[${char_Choice}]}"
    typeset local      file_Link="${dir_Job}/${str_JobState}/${arr_Jobs[${char_Choice}]}"
    typeset local file_ActiveJob="${dir_Active}/${arr_Jobs[${char_Choice}]}"
    typeset local       file_Log="${dir_Log}/$(basename ${file_Job})".log
    while : ; do
      fn_JobInfo
      type fnE_RulesMenu >/dev/null 2>&1 && fnE_RulesMenu
      fn_ContextMenu ${str_JobState}
      read -n 1 -t 30 char_Choice

      case ${char_Choice} in
	
        # 
        ## Abort Failed or Running jobs
        c | C ) fn_Cancel "${file_Link}" "${str_JobState}" ;;

        ## View CSV
        #c | C ) ${cmd_Editor} "${file_CSV}" ;;

        ## Edit job
        v | V ) fn_ViewJob "${file_ActiveJob}" ;;
        e | E ) fn_EditJob "${file_ActiveJob}" ;;
		        #fn_CheckOwner "${file_ActiveJob}"
                #${cmd_Editor} "${file_ActiveJob}" ;;
        l | L ) ${cmd_Editor} "${file_Log}" ;;

        ## Job State transition
		
        ## Delete Job(s)
        d | D ) fn_CheckOwner "${file_ActiveJob}"
                fn_Audit "${file_Job}" deleted
                echo ",,,$(date +%s),$(basename ${file_Job}),,,-1,${str_User}" >> "${file_CSV}"
                mv "${file_Link}" "${dir_Deleted}"
                return 0 ;;

        ## Queue Job(s)
        q | Q ) fn_CheckOwner "${file_ActiveJob}"
                fn_Audit "${file_Job}" queued
                fn_UpdateResumePoint "${file_Job}" 0
                if [ -r "${dir_Active}/$(basename ${file_Job})".rules ] ; then
                  mv "${file_Link}" "${dir_Pending}"
                else
                  mv "${file_Link}" "${dir_Queued}"
                fi
                fn_CheckDispatcher
                return 0 ;;

        ## Resume Job(s)
        r | R ) fn_CheckOwner "${file_ActiveJob}"
                fn_Audit "${file_Job}" "resumed task:$(fn_GetResumePoint ${file_Log} ) "
                fn_LogWhy
                fn_UpdateResumePoint "${file_Job}" $(fn_GetResumePoint ${file_Log})
                mv "${file_Link}" "${dir_Queued}"
                fn_CheckDispatcher
                return 0 ;;

        ## Skip a task in Job(s)
        s | S ) fn_CheckOwner "${file_ActiveJob}"
                fn_Audit "${file_Job}" "skipped task:$(fn_GetResumePoint ${file_Log} ) "
                fn_LogWhy
                fn_UpdateResumePoint "${file_Job}" "$(( $(fn_GetResumePoint ${file_Log}) + 1 ))"
                mv "${file_Link}" "${dir_Queued}"
                fn_CheckDispatcher
                return 0 ;;

        ## Pause Job(s)
        p | P ) fn_CheckOwner "${file_ActiveJob}"
                if [ -f "${dir_Active}"/"$(basename "${file_Job}").pause" ] ; then
                  rm "${dir_Active}"/"$(basename "${file_Job}").pause"
                  fn_Audit "${file_Job}" "pause removed. Current task will continue"
                else
                  touch "${dir_Active}"/"$(basename "${file_Job}").pause"
                  fn_Audit "${file_Job}" "pause set. Current task will not complete"
                fi
                fn_LogWhy		
                return 0 ;;

        ## Unqueue Job(s) back to New State
        u | U ) fn_CheckOwner "${file_ActiveJob}"
                fn_Audit "${file_Job}" unqueued
                mv "${file_Link}" "${dir_New}"  
                return 0 ;;

        ## Task View

        ## Mark Job as Fix in Progress (FIP)
        f | F ) echo " "
                read -p " You may provide a keyword or tracking id: " str_Reply
                [[ ! -z ${str_Reply} ]] && str_Reply=" [${str_Reply}]"
                fn_Audit "${file_Job}" "fix in progress"
                mv "${file_Link}" "${dir_Fixing}"
                echo "$(${fn_LogDate}) Fix in progress${str_Reply}. Resume Point:$(fn_GetResumePoint "${file_Log}" )" >> "${file_Log}"
                return 0 ;;

        ## Amend Job rules
        a | A ) fnE_AmendRules        ;;
        t     ) fn_CatchWord ${char_Choice} "tail tasks" ;;
        x | X ) return 0 ;;
        *     ) return 0 ;;
      esac
    done
  else 
    echo "Out of range"
    fn_PressEnter
  fi
  fn_SetLayout
}
readonly -f fn_AdminFunctions

fn_CatchWord()
{
  local char_ChoiceExtra="$1"
  local arr_WordList="$2"
  local int_Length=1
  local str_Word=${char_ChoiceExtra}
  local int_Del=1
  while  [ "${char_ChoiceExtra}" != "" ]  ; do
    read -n 1 -t 30 char_ChoiceExtra
    if [ "${char_ChoiceExtra}" = "" ] ; then
      int_Length=${#str_Word} 
      int_Del=$(( int_Length - 1 )) 
      (( int_Del >= 0 )) && eval str_Word=\${str_Word:0:${int_Del}} && printf "\b \b\b \b" || ( printf "\b \b" && continue )
    else
      str_Word=${str_Word}${char_ChoiceExtra}
    fi
  done
  # To be extended
  case ${str_Word} in
    t | T      ) fn_ShowTasks "${file_Job}"          ;;
    tail       ) trap "return 0" 2 ; tail -f "${file_Log}" ;;
    [0-9]*     ) fn_AdminFunctions ${str_Word}  ;;
    *          ) clear ;;
  esac
  #echo "${str_Word}"
}
