#
# Copyright 2015 WebMarcIT Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#


# function included
# fn_Manager()
# fn_AdminFunctions()


fn_Manager()
{
  typeset local char_Choice=
#  file_ScreenCache=$(mktemp "${dir_Tmp}"/cache.XXXXX)
  while : ; do
    # Use cache file
    #printf "."
    fn_ShowTop #> "${file_ScreenCache}"
    #printf "."
    #fn_ShowJobs superseded failed warning #>> "${file_ScreenCache}"
	#fn_ShowJobs completed
	fn_ShowJobs2 superseded failed running starting pending queued new completed #>> ${file_ScreenCache} ; printf "."
    fn_ShowLine "=" #>> "${file_ScreenCache}" ; printf "."
    fn_DisplayMOTD #>> "${file_ScreenCache}" ; printf "."
    #fn_ContextMenu >> "${file_ScreenCache}" ; printf "."
    #int_ScreenWidth=$(tput cols)
    #clear ; cat "${file_ScreenCache}" | cut -c 1-${int_ScreenWidth}
    printf "\n${dis_Reset}"
	fn_ContextMenu
    read -t 10 char_Choice
    #echo "."

    case ${char_Choice} in

      # Create a new job
      n | N ) "${dir_Base}"/${str_ProgramName} -new -p ${dir_Plugins} -j ${dir_Jobs};;

	  # View CSV
	  c | C ) ${cmd_Editor} "${file_CSV}" ;;

      # Job State transition
      d | D )                      fn_Transition delete  ;;
      q | Q ) fn_CheckDispatcher ; fn_Transition queue   ;;
      r | R ) fn_CheckDispatcher ; fn_Transition resume  ;;
      u | U )                      fn_Transition unqueue ;;
	  p | P )                      fn_Transition pause   ;;

      # Misc
      m | M ) fn_EditMOTD           ;;
      t | T ) fn_ShowTasks          ;;
	  [0-9]* ) fn_AdminFunctions ${char_Choice} ;;
	  open  ) fnE_MkOpenScorch      ;;

      l | L ) fn_LockManager        ;;     

      set )   fnE_Set ;;
	  
      x | X ) break ;;
    esac
	fn_RunJobs
  done
#  rm "${file_ScreenCache}"
}
readonly -f fn_Manager

fn_AdminFunctions()
{
  typeset local char_Choice=${1}
  if [[ ${char_Choice} -gt 0 ]] && [[ ${char_Choice} -lt ${int_Count} ]] ; then

  #if [[ ${char_Choice} -lt ${int_Count} ]] ; then

    typeset str_JobState=${arr_States[${char_Choice}]}
    typeset local file_Job="${dir_Active}/${arr_Jobs[${char_Choice}]}"
    typeset local file_Link="${dir_Job}/${str_JobState}/${arr_Jobs[${char_Choice}]}"
	typeset local file_ActiveJob="${dir_Active}/${arr_Jobs[${char_Choice}]}"
    typeset local file_Log="${dir_Log}/$(basename ${file_Job})".log
 #   echo "${file_Job}"
    while : ; do
      fn_JobInfo
      type fnE_RulesMenu >/dev/null 2>&1 && fnE_RulesMenu
      fn_ContextMenu ${str_JobState}
      read -t 10 char_Choice
    #echo "."

      case ${char_Choice} in
	
        # View CSV
        c | C ) ${cmd_Editor} "${file_CSV}" ;;

        # Edit job
        e | E ) ${cmd_Editor} "${file_ActiveJob}" ;;
        l | L ) ${cmd_Editor} "${file_Log}" ;;

        # Job State transition
        d | D ) fn_Audit "${file_Job}" deleted
              echo ",,,$(date +%s),$(basename ${file_Job}),,,-1,$(whoami)" >> "${file_CSV}"
              mv "${file_Link}" "${dir_Deleted}"
              return 0 ;;

        q | Q ) fn_Audit "${file_Job}" queued
              fn_UpdateResumePoint "${file_Job}" 0
              if [ -r "${dir_Active}/$(basename ${file_Job})".rules ] ; then
                mv "${file_Link}" "${dir_Pending}"
              else
                mv "${file_Link}" "${dir_Queued}"
              fi
              fn_CheckDispatcher
              return 0 ;;

        r | R ) fn_Audit "${file_Job}" "resumed task:$(fn_GetResumePoint ${file_Log} ) "
              fn_LogWhy
              fn_UpdateResumePoint "${file_Job}" $(fn_GetResumePoint ${file_Log})
              mv "${file_Link}" "${dir_Queued}"
              fn_CheckDispatcher
              return 0 ;;

        s | S ) fn_Audit "${file_Job}" "skipped task:$(fn_GetResumePoint ${file_Log} ) "
              fn_LogWhy
              fn_UpdateResumePoint "${file_Job}" "$(( $(fn_GetResumePoint ${file_Log}) + 1 ))"
              mv "${file_Link}" "${dir_Queued}"
              fn_CheckDispatcher
              return 0 ;;

        p | P ) if [ -f "${dir_Active}"/"$(basename "${file_Job}").pause" ] ; then
                  rm "${dir_Active}"/"$(basename "${file_Job}").pause"
                  fn_Audit "${file_Job}" "pause removed. Current task will continue"
                else
                  touch "${dir_Active}"/"$(basename "${file_Job}").pause"
                  fn_Audit "${file_Job}" "pause set. Current task will not complete"
                fi
                fn_LogWhy		
#            fn_Audit "${file_Job}" "pause set. Current task will complete"
#            touch "${dir_Active}/$(basename ${file_Job})".pause
                return 0 ;;
  
        u | U ) fn_Audit "${file_Job}" unqueued
              mv "${file_Link}" "${dir_New}"  
              return 0 ;;

        # Task View
        t | T ) fn_ShowTasks "${file_Job}"          ;;

        f | F ) fn_Audit "${file_Job}" "fix in progress"
              echo "$(${fn_LogDate}) Fix in progress. Resume Point:$(fn_GetResumePoint "${file_Log}" )" >> "${file_Log}" ;;

        a | A ) fnE_AmendRules        ;;

        x | X ) return 0 ;;
        *     ) return 0 ;;
      esac
    done
  else 
    echo "Out of range"
    fn_PressEnter
  fi
}
readonly -f fn_AdminFunctions
