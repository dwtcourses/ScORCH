#
# Copyright 2015 WebMarcIT Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#


# function included
# fn_Manager   # Loop
# fn_AdminFunctions


fn_Manager()
{
  typeset local char_Choice=
  file_ScreenCache=$(mktemp "${dir_Tmp}"/cache.XXXXX)
  while : ; do
    # Use cache file
    #printf "."
    fn_ShowTop #> "${file_ScreenCache}"
    #printf "."
    #fn_ShowJobs superceeded failed warning #>> "${file_ScreenCache}"
	#fn_ShowJobs completed
	fn_ShowJobs2 superceeded failed running starting queued new completed #>> ${file_ScreenCache}
    #printf "."
    fn_ShowLine "=" #>> "${file_ScreenCache}"
    #printf "."
    fn_DisplayMOTD #>> "${file_ScreenCache}"
    #printf "."
    #fn_ContextMenu >> "${file_ScreenCache}"
    #printf "."
#	int_ScreenWidth=$(tput cols)
    #clear ; cat "${file_ScreenCache}" | cut -c 1-${int_ScreenWidth}
	fn_ContextMenu
    read -t 10 char_Choice
    #echo "."

    case ${char_Choice} in

      # Create a new job
      n | N ) "${dir_Base}"/${str_ProgramName} -new -p ${dir_Plugins} -j ${dir_Jobs};;

      # Job State transition
      d | D ) fn_Transition delete  ;;
      q | Q ) fn_Transition queue   ;;
      r | R ) fn_Transition resume  ;;
      u | U ) fn_Transition unqueue ;;
	  p | P ) fn_Transition pause   ;;

      # Misc
      m | M ) fn_EditMOTD           ;;
      t | T ) fn_ShowTasks          ;;
	  [0-9]* ) fn_AdminFunctions ${char_Choice} ;;

      l | L ) fn_LockManager        ;;     
      
      x | X ) break ;;
    esac
	fn_RunJobs
  done
  rm "${file_ScreenCache}"
}
readonly -f fn_Manager

fn_AdminFunctions()
{
  if [[ ${char_Choice} -lt ${int_Count} ]] ; then
    typeset str_JobState=${arr_States[${1}]}
    typeset local file_Job="${dir_Job}"/${str_JobState}/${arr_Jobs[${1}]}
	typeset local file_ActiveJob="${dir_Active}/${arr_Jobs[${1}]}"
    typeset local file_Log="${dir_Log}/$(basename ${file_Job})".log
    echo "${file_Job}"
    clear
    fn_ShowTop
    fn_ShowLine
    typeset local str_JobOwner=$(grep ^str_Owner "${file_ActiveJob}")
    echo " Job Owner : ${str_JobOwner}"
    fn_ShowLine "-" 
    ls -l "${file_ActiveJob}"
	ls -l "${file_Log}"
    fn_ShowLine "-" 
#echo Passing ${str_JobState}
    fn_ContextMenu ${str_JobState}
    read char_Choice
    #echo "."

    case ${char_Choice} in

      # Edit job
      e | E ) vi "${file_Job}" ;;
	  l | L ) vi "${file_Log}" ;;

      # Job State transition
      d | D ) fn_Audit "${file_Job}" deleted
              mv "${file_Job}" "${dir_Deleted}" ;;

      q | Q ) fn_Audit "${file_Job}" queued
              fn_UpdateResumePoint "${file_Job}" 0
              mv "${file_Job}" "${dir_Queued}"
              fn_CheckDispatcher			    ;;

	  r | R ) fn_Audit "${file_Job}" "resumed task:$(fn_GetResumePoint ${file_Log} ) "
              fn_UpdateResumePoint "${file_Job}" $(fn_GetResumePoint ${file_Log})
              mv "${file_Job}" "${dir_Queued}"
              fn_CheckDispatcher                ;;

	  s | S ) fn_Audit "${file_Job}" "skipped task:$(fn_GetResumePoint ${file_Log} ) "
              fn_UpdateResumePoint "${file_Job}" "$(( $(fn_GetResumePoint ${file_Log}) + 1 ))"
              mv "${file_Job}" "${dir_Queued}"
              fn_CheckDispatcher                ;;

	  p | P ) fn_Audit "${file_Job}" "pause set. Current task will complete"
	          touch "${dir_Running}/$(basename ${file_Job})".pause           ;;
			  
	  u | U ) fn_Audit "${file_Job}" unqueued
              mv "${file_Job}" "${dir_New}"     ;;

      # Task View
      t | T ) fn_ShowTasks "${file_Job}"          ;;

	  f | F ) fn_Audit "${file_Job}" "fix in progress"
              echo "Fix in Progress: Resume Point:$(fn_GetResumePoint "${file_Log}" )" >> "${file_Log}" ;;

      x | X ) break ;;
    esac
    sleep .5 #Here to allow NAS to catch up
  else 
    echo "Out of range"
    fn_PressEnter
  fi
}
readonly -f fn_AdminFunctions
