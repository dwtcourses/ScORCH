#
# Copyright 2016 WebMarcIT Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

# These functions manage the manager/view screen
# fn_Manager()
# fn_AdminFunctions()


fn_Manager()
{
  typeset local char_Choice=
  while : ; do
    fn_ShowTop
	fn_ShowJobs2 superseded failed fixing running starting pending queued new completed
    fn_ShowLine "="
    fn_DisplayMOTD
    printf "\n${dis_Reset}"
	fn_ContextMenu
    read -t ${int_Refresh} char_Choice

    case ${char_Choice} in

      # Create a new job
      n | N ) "${dir_Base}"/${str_ProgramName} -new -p ${dir_Plugins} -j ${dir_Jobs};;

	  # View CSV
	  c | C ) ${cmd_Editor} "${file_CSV}" ;;

      # Job State transition
      d | D )                      fn_Transition delete  ;;
      q | Q ) fn_CheckDispatcher ; fn_Transition queue   ;;
      r | R ) fn_CheckDispatcher ; fn_Transition resume  ;;
      u | U )                      fn_Transition unqueue ;;
	  p | P )                      fn_Transition pause   ;;

      # Misc
      m | M ) fn_EditMOTD           ;;
      t | T ) fn_ShowTasks          ;;
	  [0-9]* ) fn_AdminFunctions ${char_Choice} ;;
	  
	  # Releases
	  open       ) fnE_MkOpenScorch ;;
	  enterprise ) fnE_MkEscorchtar ;;

      l | L ) fn_LockManager        ;;     

      set )   fnE_Set ;;
	  
      x | X ) break ;;
    esac
	fn_RunJobs
  done
}
readonly -f fn_Manager

fn_ViewJob()
{
  typeset local file_Orig="$1"
  typeset local file_View="${file_Orig}.$$"
  cp "${file_Orig}" "${file_View}"
  ${cmd_Editor} "${file_View}"
  if ! diff "${file_Orig}" "${file_View}" ; then
    printf "\n\nWarning. Not in edit mode. Changes will not be saved.\n"
	read -n 1 -p "Do you want to save your changes to /tmp? [y/n] " char_Answer
	printf "\n\n"
	if [[ "${char_Answer}" = "y" ]] || [[ "${char_Answer}" = "Y" ]] ; then
	  mv "${file_View}" /tmp/$(basename "${file_Orig}")
      fn_Audit "${file_Orig}" "saved an edited copy of job and saved a copy in /tmp"
    fi
	#fn_PressEnter
  fi
  [ -f "${file_View}" ] && rm -f "${file_View}"
}

fn_EditJob()
{
  typeset local file_Orig="$1"
  fn_CheckOwner "${file_Orig}"
  typeset local file_Edit="${file_Orig}.$$"
  cp "${file_Orig}" "${file_Edit}"
  ${cmd_Editor} "${file_Edit}"
  if ! diff "${file_Orig}" "${file_Edit}" ; then
	  mv "${file_Edit}" "${file_Orig}"
      fn_Audit "${file_Orig}" "edited job"
  fi
  [ -f "${file_Edit}" ] && rm -f "${file_Edit}"
  
}

fn_AdminFunctions()
{
  typeset local char_Choice=${1}
  if [[ ${char_Choice} -gt 0 ]] && [[ ${char_Choice} -lt ${int_Count} ]] ; then

  #if [[ ${char_Choice} -lt ${int_Count} ]] ; then

    typeset str_JobState=${arr_States[${char_Choice}]}
    typeset local file_Job="${dir_Active}/${arr_Jobs[${char_Choice}]}"
    typeset local file_Link="${dir_Job}/${str_JobState}/${arr_Jobs[${char_Choice}]}"
	typeset local file_ActiveJob="${dir_Active}/${arr_Jobs[${char_Choice}]}"
    typeset local file_Log="${dir_Log}/$(basename ${file_Job})".log
    while : ; do
      fn_JobInfo
      type fnE_RulesMenu >/dev/null 2>&1 && fnE_RulesMenu
      fn_ContextMenu ${str_JobState}
      read -t 10 char_Choice

      case ${char_Choice} in
	
        # View CSV
        c | C ) ${cmd_Editor} "${file_CSV}" ;;

        # Edit job
        v | V ) fn_ViewJob "${file_ActiveJob}" ;;
        e | E ) fn_EditJob "${file_ActiveJob}" ;;
		        #fn_CheckOwner "${file_ActiveJob}"
                #${cmd_Editor} "${file_ActiveJob}" ;;
        l | L ) ${cmd_Editor} "${file_Log}" ;;

        # Job State transition
		
        # Delete Job(s)
        d | D ) fn_CheckOwner "${file_ActiveJob}"
                fn_Audit "${file_Job}" deleted
                echo ",,,$(date +%s),$(basename ${file_Job}),,,-1,$(whoami)" >> "${file_CSV}"
                mv "${file_Link}" "${dir_Deleted}"
                return 0 ;;

        # Queue Job(s)
        q | Q ) fn_CheckOwner "${file_ActiveJob}"
                fn_Audit "${file_Job}" queued
                fn_UpdateResumePoint "${file_Job}" 0
                if [ -r "${dir_Active}/$(basename ${file_Job})".rules ] ; then
                  mv "${file_Link}" "${dir_Pending}"
                else
                  mv "${file_Link}" "${dir_Queued}"
                fi
                fn_CheckDispatcher
                return 0 ;;

        # Resume Job(s)
        r | R ) fn_CheckOwner "${file_ActiveJob}"
                fn_Audit "${file_Job}" "resumed task:$(fn_GetResumePoint ${file_Log} ) "
                fn_LogWhy
                fn_UpdateResumePoint "${file_Job}" $(fn_GetResumePoint ${file_Log})
                mv "${file_Link}" "${dir_Queued}"
                fn_CheckDispatcher
                return 0 ;;

        # Skip a task in Job(s)
        s | S ) fn_Audit "${file_Job}" "skipped task:$(fn_GetResumePoint ${file_Log} ) "
                fn_LogWhy
                fn_UpdateResumePoint "${file_Job}" "$(( $(fn_GetResumePoint ${file_Log}) + 1 ))"
                mv "${file_Link}" "${dir_Queued}"
                fn_CheckDispatcher
                return 0 ;;

        # Pause Job(s)
        p | P ) fn_CheckOwner "${file_ActiveJob}"
                if [ -f "${dir_Active}"/"$(basename "${file_Job}").pause" ] ; then
                  rm "${dir_Active}"/"$(basename "${file_Job}").pause"
                  fn_Audit "${file_Job}" "pause removed. Current task will continue"
                else
                  touch "${dir_Active}"/"$(basename "${file_Job}").pause"
                  fn_Audit "${file_Job}" "pause set. Current task will not complete"
                fi
                fn_LogWhy		
                return 0 ;;

        # Unqueue Job(s) back to New State
        u | U ) fn_CheckOwner "${file_ActiveJob}"
                fn_Audit "${file_Job}" unqueued
                mv "${file_Link}" "${dir_New}"  
                return 0 ;;

        # Task View
        t | T ) fn_ShowTasks "${file_Job}"          ;;

        # Mark Job as Fix in Progress (FIP)
        f | F ) echo " "
                read -p " You may provide a keyword or tracking id: " str_Reply
				[[ ! -z ${str_Reply} ]] && str_Reply=" [${str_Reply}]"
		        fn_Audit "${file_Job}" "fix in progress"
                mv "${file_Link}" "${dir_Fixing}"
                echo "$(${fn_LogDate}) Fix in progress${str_Reply}. Resume Point:$(fn_GetResumePoint "${file_Log}" )" >> "${file_Log}"
                return 0 ;;

        # Amend Job rules
        a | A ) fnE_AmendRules        ;;
		tail  ) trap "return 0" 2 ; tail -f "${file_Log}" ;;

        x | X ) return 0 ;;
        *     ) return 0 ;;
      esac
    done
  else 
    echo "Out of range"
    fn_PressEnter
  fi
  fn_SetLayout
}
readonly -f fn_AdminFunctions
