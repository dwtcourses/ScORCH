#
# Copyright 2015 WebMarcIT Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#


# function included
# fn_Manager   # Loop
# fn_AdminFunctions


fn_Manager()
{
  typeset local char_Choice=
#  file_ScreenCache=$(mktemp "${dir_Tmp}"/cache.XXXXX)
  while : ; do
    # Use cache file
    #printf "."
    fn_ShowTop #> "${file_ScreenCache}"
    #printf "."
    #fn_ShowJobs superseded failed warning #>> "${file_ScreenCache}"
	#fn_ShowJobs completed
	fn_ShowJobs2 superseded failed running starting pending queued new completed #>> ${file_ScreenCache} ; printf "."
    fn_ShowLine "=" #>> "${file_ScreenCache}" ; printf "."
    fn_DisplayMOTD #>> "${file_ScreenCache}" ; printf "."
    #fn_ContextMenu >> "${file_ScreenCache}" ; printf "."
    #int_ScreenWidth=$(tput cols)
    #clear ; cat "${file_ScreenCache}" | cut -c 1-${int_ScreenWidth}
    printf "\n${dis_Reset}"
	fn_ContextMenu
    read -t 20 char_Choice
    #echo "."

    case ${char_Choice} in

      # Create a new job
      n | N ) "${dir_Base}"/${str_ProgramName} -new -p ${dir_Plugins} -j ${dir_Jobs};;

	  # View CSV
	  c | C ) vi "${file_CSV}" ;;

      # Job State transition
      d | D )                      fn_Transition delete  ;;
      q | Q ) fn_CheckDispatcher ; fn_Transition queue   ;;
      r | R ) fn_CheckDispatcher ; fn_Transition resume  ;;
      u | U )                      fn_Transition unqueue ;;
	  p | P )                      fn_Transition pause   ;;

      # Misc
      m | M ) fn_EditMOTD           ;;
      t | T ) fn_ShowTasks          ;;
	  [0-9]* ) fn_AdminFunctions ${char_Choice} ;;

      l | L ) fn_LockManager        ;;     

      set )   fnE_Set ;;
	  
      x | X ) break ;;
    esac
	fn_RunJobs
  done
#  rm "${file_ScreenCache}"
}
readonly -f fn_Manager

fn_AdminFunctions()
{
  typeset local char_Choice=${1}
  if [[ ${char_Choice} -lt ${int_Count} ]] ; then

    typeset str_JobState=${arr_States[${char_Choice}]}
    typeset local file_Job="${dir_Active}/${arr_Jobs[${char_Choice}]}"
    typeset local file_Link="${dir_Job}/${str_JobState}/${arr_Jobs[${char_Choice}]}"
	typeset local file_ActiveJob="${dir_Active}/${arr_Jobs[${char_Choice}]}"
    typeset local file_Log="${dir_Log}/$(basename ${file_Job})".log
 #   echo "${file_Job}"
    while : ; do
      clear
      fn_ShowTop
      fn_ShowLine "-" "Owner"
      typeset local str_JobOwner=$(grep ^str_Owner "${file_ActiveJob}")
      echo " ${str_JobOwner}"
      echo ""
      fn_ShowLine "-" "File details"
      echo " State at selection : ${str_JobState}"
      echo ""
      ls -lL "${file_ActiveJob}"
      ls -lL "${file_Log}"
      echo ""
	  fn_ShowRules
      fn_ShowLine "-" "Log Summary"
      tail -10 "${file_Log}"
      echo ""
      fn_ShowLine "-" 
      printf "\n${dis_Reset}"
      type fnE_RulesMenu >/dev/null 2>&1 && fnE_RulesMenu
      fn_ContextMenu ${str_JobState}
      read -t 10 char_Choice
    #echo "."

      case ${char_Choice} in
	
	    # View CSV
	    c | C ) vi "${file_CSV}" ;;

        # Edit job
        e | E ) vi "${file_ActiveJob}" ;;
	    l | L ) vi "${file_Log}" ;;

        # Job State transition
        d | D ) fn_Audit "${file_Job}" deleted
              mv "${file_Link}" "${dir_Deleted}"
              return 0 ;;

        q | Q ) fn_Audit "${file_Job}" queued
              fn_UpdateResumePoint "${file_Job}" 0
              if [ -r "${dir_Active}/$(basename ${file_Job})".rules ] ; then
                mv "${file_Link}" "${dir_Pending}"
              else
                mv "${file_Link}" "${dir_Queued}"
              fi
              fn_CheckDispatcher
              return 0 ;;

	    r | R ) fn_Audit "${file_Job}" "resumed task:$(fn_GetResumePoint ${file_Log} ) "
              fn_LogWhy
              fn_UpdateResumePoint "${file_Job}" $(fn_GetResumePoint ${file_Log})
              mv "${file_Link}" "${dir_Queued}"
              fn_CheckDispatcher
              return 0 ;;

	    s | S ) fn_Audit "${file_Job}" "skipped task:$(fn_GetResumePoint ${file_Log} ) "
              fn_LogWhy
              fn_UpdateResumePoint "${file_Job}" "$(( $(fn_GetResumePoint ${file_Log}) + 1 ))"
              mv "${file_Link}" "${dir_Queued}"
              fn_CheckDispatcher
              return 0 ;;

	    p | P ) fn_Audit "${file_Job}" "pause set. Current task will complete"
	          touch "${dir_Active}/$(basename ${file_Job})".pause
              fn_LogWhy
              return 0 ;;
			  
	    u | U ) fn_Audit "${file_Job}" unqueued
              mv "${file_Link}" "${dir_New}"  
              return 0 ;;

        # Task View
        t | T ) fn_ShowTasks "${file_Job}"          ;;

	    f | F ) fn_Audit "${file_Job}" "fix in progress"
              echo "$(${fn_LogDate}) Fix in progress. Resume Point:$(fn_GetResumePoint "${file_Log}" )" >> "${file_Log}" ;;

        a | A ) fnE_AmendRules        ;;

        x | X ) return 0 ;;
	    *     ) return 0 ;;
      esac
	done
  else 
    echo "Out of range"
    fn_PressEnter
  fi
}
readonly -f fn_AdminFunctions
