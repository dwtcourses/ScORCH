##
## Copyright 2016 WebMarcIT Ltd
##
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
##    http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##

## These functions check the layout is correct and provides common initialisation functions
## fn_CheckSetup()
## fn_Help()
## fn_HouseKeeping()
## fn_GetAnswer()
## fn_Range()
## fn_CreateFile()
## fn_GetResumePoint()
## fn_UpdateResumePoint()
## fn_PressEnter()
## fn_Trap()


# Some global variables for setup functions
typeset str_Answer=      # Used in fn_PressEnter and fn_GetAnswer

fn_CheckSetUp()
{
  typeset b_SetUp=         # Is this the first run

  # This function will check that all Scorch components are set to allow a smooth run.
  typeset local arr_Directories="dir_Pending dir_New dir_Starting dir_Failed dir_Fixing dir_Deleted \
                                 dir_Running dir_Superseded dir_Completed dir_Tmp dir_Plugins \
                                 dir_Queued dir_Active dir_Archived dir_Var dir_Log dir_Lock"
  [[ ${b_Install} ]] && printf "\n\n\tInitialising....\n\n"
  for p_Variable in ${arr_Directories} ; do
    if [[ ! -d ${!p_Variable} ]] ; then
      printf "\n\tmkdir -p -m 770 \"${!p_Variable}\"" && b_SetUp=1
      [[ ${b_Install} ]] && mkdir -p -m 770 "${!p_Variable}" && b_SetUp=

    fi
  done
  
  typeset local arr_Files="${file_DispatchLog}"
  printf "\n\n"
#  which gawk  2>/dev/null || printf "\n\tgawk not installed. Ubuntu: sudo apt-get install gawk\n"
#  which pgrep 2>/dev/null || printf "\n\tpgrep not installed. Ubuntu: sudo apt-get install pgrep\n" 
  
  arr_Commands="gawk pgrep"
  str_Install="sudo apt-get install"
  for str_Command in ${arr_Commands} ; do
    printf "\tChecking for ${str_Command}:\t"
	which ${str_Command} 2>/dev/null || ( printf "not found. ${str_Install} ${str_Command}\n" && b_SetUp=1 )
  done
  
  cmd_AWK=$(which gawk 2>/dev/null) || cmd_AWK=$(which nawk 2>/dev/null) || (printf "\n\tCant find a suitable gawk or nawk")
  printf "\n\tcmd_AWK: ${cmd_AWK}"

  if [[ ${b_SetUp} ]] ; then
    printf "\n\n\n\tThere are missing files, directories or commands.\n"
    printf "\tTo automatically create required directories, as the framework owner rerun:\n\t\t${dir_Orig}/${str_ProgramName} -install\n"
    exit 1
  fi

  str_JobPrefix="Job_"
}
readonly -f fn_CheckSetUp

fn_Help()
{
  # Help 
  echo "${str_ProgramName} "
  echo " # Options"
  echo "    -p <alternative plugin dir>   Use a different plugin directory"
  echo " "
  echo " # Help"
  echo "    -h                            Show help"
  echo "    -v                            Display version"
  echo " "
  echo " # Internal Modes"
  echo "    -dispatcher                   Run is dispatcher mode"
  echo "    -new                          Load new job from input"
  echo "    -file <file template> [-s]    Load new job from file [ and move to start ]"
  echo " "
  echo " # Admin and development "
  echo "    -p <dir>                      Use Plugins from given directory"
  echo "    -f <dir>                      Use Functions from given directory"
  echo " "
}
readonly -f fn_Help

fn_HouseKeeping()
{
  # Clean-up of dir_deleted dir_completed
  # Deleted jobs left for a period of time before tar into the deleted tar
  # Daily jobs moved to archive directory after a period of if more than MaxJobs
  # Old Archived jobs are tar'd up after DaysDeleted
  echo "Housekeeping...."

  typeset local     int_MaxJobs=${int_MaxShown}
  typeset local int_DaysDeleted=10
  typeset local  int_DaysActive=20
  
  # Need to add one for the head/tail to be valid
  (( int_MaxJobs +=1 ))

  # First remove max links from completed
  [ $(ls ${dir_Completed}/* 2> /dev/null | wc -l ) -ge ${int_MaxJobs} ] && find ${dir_Completed}/* ! -newer ${dir_Completed}/$(ls -1t ${dir_Completed} | head -${int_MaxJobs} | tail -1) -exec mv -f {} ${dir_Archived}/. \; > /dev/null 2>&1

  # Remove old completed links
  find  "${dir_Completed}"/${str_JobPrefix}* -mtime +${int_DaysDeleted} -exec rm -f {} \; 2>/dev/null

  # Remove old deleted links
  find  "${dir_Deleted}"/${str_JobPrefix}*   -mtime +${int_DaysDeleted} -exec rm -f {} \; 2>/dev/null

  # Archive active jobs
  find "${dir_Active}"/${str_JobPrefix}*    -mtime +${int_DaysActive} -exec tar uf ${dir_Active}/active.tar "{}" + 2>/dev/null && find "${dir_Active}"/${str_JobPrefix}*    -mtime +${int_DaysActive} -exec rm -f {} \; 2>/dev/null
  
  # Clean Up cache files
  find "${dir_Tmp}" -name "cache.$$.*"  -exec rm -f {} \; 2>/dev/null
  find "${dir_Tmp}" -name "scorch.$$.*" -exec rm -f {} \; 2>/dev/null

  # Show jobs that have mis-behaved 
  find "${dir_Completed}" "${dir_New}" -type f 
}
readonly -f fn_HouseKeeping

fn_GetAnswer()
{
  # Library function to get an answer or range of answers
  # =====================================================
  typeset local b_Range=${1:-""}

  printf "\n e${dis_ULOn}X${dis_ULOff}it.\n\n"
  printf " Enter choice "
  [[ "${b_Range}" ]] && printf "(range enabled : i.e 1-3,7,8) "
  printf ":"
  read str_Answer
  str_Answer=${str_Answer:-"x"}
}
readonly -f fn_GetAnswer

fn_Range()
{
  # Library function to turn a range of numbers into a list
  # =======================================================

  typeset local str_Input=${1//,/ }

  for int_EachItem in ${str_Input} ; do
    if [ "$(echo ${int_EachItem} | grep "-" )" ] ; then
#      typeset local int_First=$(echo ${int_EachItem} | cut -d "-" -f1)
#      typeset local  int_Last=$(echo ${int_EachItem} | cut -d "-" -f2)
      typeset local int_First=${int_EachItem#*-}
      typeset local  int_Last=${int_EachItem%%-*}

      if [ ${int_First} -lt ${int_Last} ] ; then
        while [[ ${int_First} -le ${int_Last} ]] ; do
          printf "${int_First} "
          ((int_First+=1))
        done
      else
        while [[ ${int_First} -ge ${int_Last} ]] ; do
          printf "${int_First} "
          ((int_First-=1))
        done
      fi
    else
      printf  "${int_EachItem} "
    fi
  done
}
readonly -f fn_Range

fn_CreateFile()
{
  typeset local file_Name="${1}"
  typeset local b_Blank="${2}"
  touch "${file_Name}" 
  [[ $? -ne 0 ]] && echo "Error: Cannot create file ${file_Name}" && exit 1
  chmod 664 "${file_Name}"
  [[ "${b_Blank}" ]] && > "${file_Name}"
}
readonly -f fn_CreateFile

fn_GetResumePoint()
{
  typeset local file_Log="${1}"
  tail -10 "${file_Log}" | grep "Resume point:" | tail -1 | awk -F":" '{print $NF}'
}
readonly -f fn_GetResumePoint

fn_UpdateResumePoint()
{
  typeset local file_Job="${1}"                             # The Job to update
  typeset local int_ResumePoint="${2:-0}"                   # The new start task
  typeset local file_Log="${dir_Log}/$(basename ${file_Job})".log
  [[ "$(dirname ${file_Job})" = "${dir_Failed}" ]] && fn_LogWhy
  (( int_ResumePoint+=0 ))                                  # Just in case a string number has been passed
  cat "${file_Job}" | sed s/^int_ResumePoint=.*/int_ResumePoint=${int_ResumePoint}/ > "${file_Job}".tmp
  [[ "$(grep ^int_ResumePoint "${file_Job}".tmp)" ]] && cp "${file_Job}".tmp "${file_Job}" ; rm "${file_Job}".tmp 2>/dev/null
  [[ int_ResumePoint -eq 0 ]] && echo "$(${fn_LogDate}) Starting from task 0" >> "${file_Log}" || echo "$(${fn_LogDate}) Resuming from task ${int_ResumePoint}" >> "${file_Log}"
}
readonly -f fn_UpdateResumePoint

fn_PressEnter()
{
  printf "\n\n"
  read -p " Press Enter to continue "
}
readonly -f fn_PressEnter

fn_Trap()
{
  echo "$(${fn_LogDate}) ${1}" >> "${file_ProgLog}"
  fn_HouseKeeping
  exit 1
}
readonly -f fn_Trap

trap "fn_Trap \"TERMINATED: User $(whoami) probably logged out \"" 1
trap "fn_Trap \"TERMINATED: User $(whoami) probably ctrl-c \"" 2
trap "fn_Trap \"TERMINATED: Probably via kill \"" 15
