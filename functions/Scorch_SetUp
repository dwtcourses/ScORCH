#
# Copyright 2015 WebMarcIT Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

# Functions
# fn_CheckSetup
# fn_Help
# fn_HouseKeeping
# fn_GetAnswer
# fn_Range()
# fn_CreateFile()
# fn_GetResumePoint()
# fn_UpdateResumePoint()
# fn_PressEnter()


# Some global variables for setup functions
typeset str_Answer=      # Used in fn_PressEnter and fn_GetAnswer

fn_CheckSetUp()
{
  typeset b_SetUp=         # Is this the first run

  # This function will check that all Scorch components are set to allow a smooth run.
  typeset local arr_Directories="dir_Pending dir_New dir_Starting dir_Failed dir_Deleted \
                                 dir_Running dir_Superceeded dir_Completed dir_Tmp \
                                 dir_Queued dir_Active dir_Var dir_Log dir_Lock"
  [[ ${b_Install} ]] && printf "\n\n\tInitialising....\n\n"
  for p_Variable in ${arr_Directories} ; do
    if [[ ! -d ${!p_Variable} ]] ; then
      printf "\n\tmkdir -p -m 770 \"${!p_Variable}\"" && b_SetUp=1
      [[ ${b_Install} ]] && mkdir -p -m 770 "${!p_Variable}" && b_SetUp=

    fi
  done
  
  typeset local arr_Files="${file_DispatchLog}"

  if [[ ${b_SetUp} ]] ; then
    printf "\n\n\nThere are missing files and directories.\n"
    printf "Please rerun \t ${dir_Orig}/${str_ProgramName} -install\n"
    printf "as the framework owner.\n"
    exit 1
  fi

  str_JobPrefix="Job_"
}
readonly -f fn_CheckSetUp

fn_Help()
{
  # Help 
  echo "${str_ProgramName} "
  echo " # Options"
  echo "    -p <alternative plugin dir>   Use a different plugin directory"
  echo " "
  echo " # Help"
  echo "    -h                            Show help"
  echo "    -v                            Display version"
  echo " "
  echo " # Internal Modes"
  echo "    -dispatcher                   Run is dispatcher mode"
  echo "    -new                          Load new job from input"
  echo "    -file <file template> [-s]    Load new job from file [ and move to start ]"
  echo " "
  echo " # Admin and development "
  echo "    -p <dir>                      Use Plugins from given directory"
  echo "    -f <dir>                      Use Functions from given directory"
  echo " "
}
readonly -f fn_Help

fn_HouseKeeping()
{
  # Cleanup of dir_deleted dir_completed
  echo "Housekeeping...."

  typeset local     int_MaxJobs=30
  typeset local int_DaysDeleted=10

  find "${dir_Deleted}"/${str_JobPrefix}*    -mtime +${int_DaysDeleted}
  find "${dir_Completed}"/${str_JobPrefix}*  -mtime +${int_DaysDeleted}

  rm "${dir_New}"/${str_JobPrefix}file
}
readonly -f fn_HouseKeeping

fn_GetAnswer()
{
  # Library function to get an answer or range of answers
  # =====================================================

  typeset local b_Range=${1:-""}

  printf "\n e${dis_ULOn}X${dis_ULOff}it.\n\n"
  printf " Enter choice "
  [[ "${b_Range}" ]] && printf "(range enabled : i.e 1-3,7,8) "
  printf ":"
  read str_Answer
  str_Answer=${str_Answer:-"x"}
}
readonly -f fn_GetAnswer

fn_Range()
{
  # Library function to turn a range of numbers into a list
  # =======================================================

  typeset local str_Input=$(echo $1 | tr ',' ' ')

  for int_EachItem in ${str_Input} ; do
    if [ "$(echo ${int_EachItem} | grep "-" )" ] ; then
      typeset local int_First=$(echo ${int_EachItem} | cut -d "-" -f1)
      typeset local  int_Last=$(echo ${int_EachItem} | cut -d "-" -f2)

      if [ ${int_First} -lt ${int_Last} ] ; then
        while [[ ${int_First} -le ${int_Last} ]] ; do
          printf "${int_First} "
          ((int_First+=1))
        done
      else
        while [[ ${int_First} -ge ${int_Last} ]] ; do
          printf "${int_First} "
          ((int_First-=1))
        done
      fi
    else
      printf  "${int_EachItem} "
    fi
  done
}
readonly -f fn_Range

fn_CreateFile()
{
  typeset local file_Name="${1}"
  typeset local b_Blank="${2}"
  touch "${file_Name}" 
  [[ $? -ne 0 ]] && echo "Error: Cannot create file ${file_Name}" && exit 1
  chmod 664 "${file_Name}"
  [[ "${b_Blank}" ]] && > "${file_Name}"
}
readonly -f fn_CreateFile

fn_GetResumePoint()
{
  typeset local file_Log="${1}"
  tail -10 "${file_Log}" | grep "Resume point:" | tail -1 | awk -F":" '{print $NF}'
}
readonly -f fn_GetResumePoint

fn_UpdateResumePoint()
{
  typeset local file_Job="${1}"                             # The Job to update
  typeset local int_ResumePoint="${2:-0}"                   # The new start task
  typeset local file_Log="${dir_Log}/$(basename ${file_Job})".log
  [[ "$(dirname ${file_Job})" = "${dir_Failed}" ]] && fn_LogWhy
  (( int_ResumePoint+=0 ))                                  # Just in case a string number has been passed
  cat "${file_Job}" | sed s/^int_ResumePoint=.*/int_ResumePoint=${int_ResumePoint}/ > "${file_Job}".tmp
  [[ "$(grep ^int_ResumePoint "${file_Job}".tmp)" ]] && cp "${file_Job}".tmp "${file_Job}" && rm "${file_Job}".tmp
  [[ int_ResumePoint -eq 0 ]] && echo "$(${fn_LogDate}) Starting from task 0" >> "${file_Log}" || echo "$(${fn_LogDate}) Resuming from task ${int_ResumePoint}" >> "${file_Log}"
}
readonly -f fn_UpdateResumePoint

fn_PressEnter()
{
  printf "\n\n"
  read -p " Press Enter to continue "
}
readonly -f fn_PressEnter

