##
## Copyright 2016 WebMarcIT Ltd
##
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
##    http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##

## These functions check the layout is correct and provides common initialisation functions
## fn_CheckSetup()
## fn_Help()
## fn_HouseKeeping()
## fn_GetAnswer()
## fn_Range()
## fn_CreateFile()
## fn_GetResumePoint()
## fn_UpdateResumePoint()
## fn_PressEnter()
## fn_Trap()


# Some global variables for setup functions
typeset str_Answer=      # Used in fn_PressEnter and fn_GetAnswer

fn_CheckSetUp()
{
  typeset b_SetUp=         # Is this the first run

  # This function will check that all Scorch components are set to allow a smooth run.
  typeset local arr_Directories="dir_Pending dir_New dir_Starting dir_Failed dir_Fixing dir_Deleted \
                                 dir_Running dir_Superseded dir_Manual dir_Completed dir_Tmp dir_Plugins \
                                 dir_Queued dir_Active dir_Archived dir_Var dir_Log dir_Lock dir_Etc"
  [[ ${b_Install} ]] && printf "\n\n\tInitialising....\n\n"

  for p_Variable in ${arr_Directories} ; do
    if [[ ! -d "${!p_Variable}" ]] ; then
      printf "\n\tmkdir -p -m 770 \"${!p_Variable}\"" && b_SetUp=1
      [[ ${b_Install} ]] && mkdir -p -m 770 "${!p_Variable}" && b_SetUp=

    fi
  done

  typeset local arr_Files="${file_DispatchLog}"
  printf "\n\n"
#  which gawk  2>/dev/null || printf "\n\tgawk not installed. Ubuntu: sudo apt-get install gawk\n"
#  which pgrep 2>/dev/null || printf "\n\tpgrep not installed. Ubuntu: sudo apt-get install pgrep\n"

  arr_Commands="gawk pgrep"
  str_Install="sudo apt-get install"
  for str_Command in ${arr_Commands} ; do
    printf "\tChecking for ${str_Command}:\t"
    which ${str_Command} 2>/dev/null || ( printf "not found. ${str_Install} ${str_Command}\n" && b_SetUp=1 )
  done

  cmd_AWK=$(which gawk 2>/dev/null) || cmd_AWK=$(which nawk 2>/dev/null) || (printf "\n\tCant find a suitable gawk or nawk")
  printf "\n\tcmd_AWK: ${cmd_AWK}\n"

  cmd_TPUT=$(which tput 2>/dev/null) || cmd_TPUT="echo"
  cmd_CLEAR=$(which clear 2>/dev/null) || cmd_CLEAR="echo \"\""
  (( b_NonInteractive == 1 )) && cmd_CLEAR="echo \"\""

#  cmd_CLEAR="echo -e \"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\""

  if [[ ${b_SetUp} ]] ; then
    printf "\n\n\n\tThere are missing files, directories or commands.\n"
    printf "\tTo automatically create required directories, as the framework owner rerun:\n\t\t${dir_Orig}/${str_ProgramName} -install\n"
    sleep 2
    exit 1
  fi

  str_JobPrefix="Job_"
}
readonly -f fn_CheckSetUp

fn_SetPrefs()
{
  if [[ -f ${file_Prefs} ]] ; then
    source ${file_Prefs}
  else
    echo '
## Layout Option
## =============
# Maximum number of jobs to show (useful for screen size preferences. Auto size is 999)
export      int_MaxShown="999"

# Inactivity timeout before returning to previous menu (suggested: 20)
export       int_Refresh="20"

# Number of log lines to show from the bottom of the log file (suggested: 25)
export          int_Tail="25"

# Editor to use when viewing log files, scorch jobs and the preferences file (suggested: vi)
export        cmd_Editor="vi"

# Allow quick menu options (suggested value for novice=0 expert=1)
export           b_Quick="0"
' >> ${file_Prefs}
fi
}

fn_Help()
{
  # Help
  echo "${str_ProgramName}"
  echo " # Options"
  echo "    -p <alternative plugin dir>   Use a different plugin directory"
  echo " "
  echo " # Help"
  echo "    -h                            Show help"
  echo "    -v                            Display version"
  echo " "
  echo " # Internal Modes                 "
  echo "    -dispatcher                   Run in dispatcher mode"
  echo "    -new                          Load new job from input"
  echo "    -file <file template> [-s]    Load new job from file [ and move to start ]"
  echo " "
  echo " # Admin and development "
  echo "    -p <dir>                      Use Plugins from given directory"
  echo "    -f <dir>                      Use Functions from given directory"
  echo " "
  echo " # Command Line Advanced Options"
  echo "    -a <ActionName>               Action Name"
  echo "    -o <keyname>:<keyvalue>       A keypair for the action"
  echo "    -s [-sync]                    Start [only return to prompt when job completes or fails]"
  echo ""
  echo " # Example"
  echo "    scorch -a SAFEDEMO -o key1:value1 -o key2:val2 -s"
}
readonly -f fn_Help

fn_HouseKeeping()
{
  # Clean-up of dir_deleted dir_completed
  # Deleted jobs left for a period of time before tar into the deleted tar
  # Daily jobs moved to archive directory after a period of if more than MaxJobs
  # Old Archived jobs are tar'd up after DaysDeleted
  echo "Housekeeping...."

  typeset local     int_MaxJobs=${int_MaxShown}
  typeset local int_DaysDeleted=10
  typeset local  int_DaysActive=30

  # Need to add one for the head/tail to be valid
  (( int_MaxJobs +=1 ))

  # First remove max links from completed
  SAVEIFS=$IFS
  IFS=$(echo -en "\n\b")

  [ $(ls "${dir_Completed}/*" 2> /dev/null | wc -l ) -ge ${int_MaxJobs} ] && find "${dir_Completed}/*" ! -newer "${dir_Completed}/$(ls -1t ${dir_Completed} | head -${int_MaxJobs} | tail -1)" -exec mv -f {} ${dir_Archived}/. \; > /dev/null 2>&1

  # Remove old completed links
  find -H "${dir_Completed}"/${str_JobPrefix}* -mtime +${int_DaysDeleted} -exec echo {} \; 2>/dev/null
  find "${dir_Completed}"/${str_JobPrefix}* -mtime +${int_DaysDeleted} -exec rm -f {} \; 2>/dev/null

  # Remove old deleted links
  find "${dir_Deleted}"/${str_JobPrefix}* -mtime +${int_DaysDeleted} -exec rm -f {} \; 2>/dev/null

  # Archive old active jobs
  ( cd "${dir_Active}" && find ./${str_JobPrefix}*  -mtime +${int_DaysActive} -exec tar uf "${dir_Active}/active.tar" "{}" + 2>/dev/null )
  find "${dir_Active}/${str_JobPrefix}*"  -mtime +${int_DaysActive} -exec rm -f {} \; 2>/dev/null

  [[ -w ${file_Cache} ]] && rm ${file_Cache}

  # Touch active New etc jobs (Sometimes old jobs are still being used even after a long time)
  # Recover jobs jobs that have taking a long time to progress
  #(cd ${dir_Active} && find "${dir_Completed}" "${dir_New}" -type f -exec tar xf ${dir_Active}/active.tar "{}" + )
  arr_Recover=$( cd "${dir_New}" && find . -name "${str_JobPrefix}*" -mtime +${int_DaysActive} )
  echo ${arr_Recover}
  for file_Recover in ${arr_Recover} ; do
    ( cd "${dir_Active}" && tar xf active.tar ${file_Recover} )
  done

  IFS=Â£{SAVEIFS}
  # Clean Up cache files
  find "${dir_Tmp}" -name "cache.$$.*"  -exec rm -f {} \; 2>/dev/null
  find "${dir_Tmp}" -name "scorch.$$.*" -exec rm -f {} \; 2>/dev/null
}
readonly -f fn_HouseKeeping

fn_GetAnswer()
{
  # Library function to get an answer or range of answers
  # =====================================================
  typeset local b_Range=${1:-""}

  printf "\n e${dis_ULOn}X${dis_ULOff}it.\n\n"
  printf " Enter choice "
  [[ "${b_Range}" ]] && printf "(range enabled : i.e 1-3,7,8)"
  printf ": "
  read -e str_Answer
  str_Answer=${str_Answer:-"x"}
}
readonly -f fn_GetAnswer

fn_Range()
{
  # Library function to turn a range of numbers into a list
  # =======================================================

  typeset local str_Input=${1//,/ }

  for int_EachItem in ${str_Input} ; do
    if [ "$(echo ${int_EachItem} | grep "-" )" ] ; then
#     typeset local int_First=$(echo ${int_EachItem} | cut -d "-" -f1)
#     typeset local  int_Last=$(echo ${int_EachItem} | cut -d "-" -f2)
      typeset local  int_First=${int_EachItem%%-*}
      typeset local int_Last=${int_EachItem#*-}

      if [ ${int_First} -le ${int_Last} ] ; then
        while [[ ${int_First} -le ${int_Last} ]] ; do
          printf "${int_First} "
          ((int_First+=1))
        done
      else
        while [[ ${int_First} -ge ${int_Last} ]] ; do
          printf "${int_First} "
          ((int_First-=1))
        done
      fi
    else
      printf  "${int_EachItem} "
    fi
  done
}
readonly -f fn_Range

fn_RangeTUI()
{
  # arr_List="a b c d e f g"
  # fn_RangeTUI "${arr_List}" "$(fn_Range "1,3,5,7")"
  # fn_RangeTUI "${arr_List}" "$(fn_Range "1-4,7")"
  typeset local arr_Input=${1}
  typeset local arr_Range=${2:-0}
  typeset local int_Count=0
  for each_Input in ${arr_Input} ; do
    (( int_Count++ ))
    [[ "$(echo ${arr_Range} | grep -w ${int_Count})" ]] && c_Selected=">" || c_Selected=" "
    echo "[${c_Selected}] ${each_Input}"
  done
}

fn_CreateFile()
{
  typeset local file_Name="${1}"
  typeset local b_Blank="${2}"
  touch "${file_Name}"
  [[ $? -ne 0 ]] && echo "Error: Cannot create file ${file_Name}" && exit 1
  chmod 664 "${file_Name}"
  [[ "${b_Blank}" ]] && > "${file_Name}"
}
readonly -f fn_CreateFile

fn_GetResumePoint()
{
  typeset local file_Log="${1}"
  tail -500 "${file_Log}" | grep "Resume point:" | tail -1 | ${cmd_AWK} -F":" '{print $NF}'
}
readonly -f fn_GetResumePoint

fn_UpdateResumePoint()
{
  # Updates the "ACTIVE" job 
  typeset local file_Job="${1}"                             # The Job to update
  typeset local int_ResumePoint="${2:-0}"                   # The new start task
  typeset local file_Log="${dir_Log}/$(basename ${file_Job})".log
  (( int_ResumePoint+=0 ))                                  # Just in case a string number has been passed
  sed s/^int_ResumePoint=.*/int_ResumePoint=${int_ResumePoint}/ "${file_Job}" > "${file_Job}".tmp
  [[ "$(grep ^int_ResumePoint "${file_Job}".tmp)" ]] && cp "${file_Job}".tmp "${file_Job}" ; rm "${file_Job}".tmp 2>/dev/null
  [[ int_ResumePoint -eq 0 ]] && echo "$(${fn_LogDate}) Starting from task 0" >> "${file_Log}" || echo "$(${fn_LogDate}) Resuming from task ${int_ResumePoint}" >> "${file_Log}"
}
readonly -f fn_UpdateResumePoint

fn_PressEnter()
{
  if [[ !  "${b_NonInteractive}" ]] ; then
    printf "\n\n"
    read -n 1 -p " Press any key to continue"
  else
    printf "\nNon Interactive Mode\n"
  fi
}
readonly -f fn_PressEnter

fn_Trap()
{
  echo "${fn_LogDate} ${1}" >> "${file_ProgLog}"
  fn_HouseKeeping
  exit 1
}
trap "fn_Trap \"TERMINATED: User ${str_User} probably logged out \"" 1
trap "fn_Trap \"TERMINATED: User ${str_User} probably ctrl-c \"" 2
trap "fn_Trap \"TERMINATED: Probably via kill \"" 15
readonly -f fn_Trap

fn_Select()
{
  typeset -a arr_Temp=
}
readonly fn_Select
