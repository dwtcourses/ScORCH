#
# Copyright 2015 WebMarcIT Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

# This file contains functions to set and display layout
# fn_SetLayout()
# fn_ShowTop()
# fn_ShowLine()
# fn_ShowJobs2()
# fn_FormatTasks()
# fn_ShowTasks()
# fn_JobInfo()
# fn_ContextMenu()


fn_SetLayout()
{
  # Define the bounds of the screen
  # The default screen layout is broken in columns to split up job names into
  # meaningfull groups
  #
  #  C1|     C2|        C3|        C4|
  #==========================================================
  #    |       |          |          |
  int_ScreenWidth=$(tput cols)
  dir_Check="${dir_New} ${dir_Completed} ${dir_Failed} ${dir_Running}"
  int_Column1Width=4        # Selection number
  int_Column2Width=8        # System reference number (like JIRA) or use ticket number
  #int_Column3Width=${int_Column3Width:-10}       # The Action / Plugin
  (( int_Column3Width=$(find ${dir_Check} -type l | awk -F"_" '{print length($4)}' | sort -un | tail -1) +1 ))
  #int_Column4Width=10       # The Environment performed on
  (( int_Column4Width=$(find ${dir_Check} -type l | awk -F"_" '{print length($5)}' | sort -un | tail -1) +1 ))
  #int_Column5Width=10       # The Version / Release being actioned
  (( int_Column5Width=$(find ${dir_Check} -type l | awk -F"_" '{print length($6)}' | sort -un | tail -1) +1 ))
#  int_Column6Width=10       # Available
  (( int_Column6Width=$(find ${dir_Check} -type l | awk -F"_" '{print length($6)}' | sort -un | tail -1) +1 ))
  int_Column7Width=10       # The Log
  cha_ColumnSep="|"
}
readonly -f fn_SetLayout


fn_ShowTop()
{
  # Display the name of the program and any interesting facts about the environment
  # ===============================================================================
  typeset local int_TitleWidth
  (( int_TitleWidth=${int_Column1Width} + ${int_Column2Width} ))
  clear

  # Check the current width of the screen
  # =====================================
  int_ScreenWidth=$(tput cols)
  #(( int_DateLocation=${int_ScreenWidth} - ${int_TitleWidth} - ${int_Column2Width} - ${int_Column3Width} - 20 ))
  (( int_DatePut = ${int_ScreenWidth} - 21 ))

  # Collect disk usage to display
  #int_DiskUsage=$(df "${dir_Base}" |  awk 'NR==2 {sub(/%/,""); if ($5 > 44 ) print "[41m"$5"[0m" else print $5}')
  int_DiskUsage=$(df "${dir_Base}" |  awk 'NR==2 {sub(/%/,""); if ($5 > 80 ) { 
                                        printf "[41m"$5"%" } 
	                                  else { 
	                                    printf $5"%"
									  }
                                      printf "[0m" }')
  # Output the program name, the dispatcher PID and the date
  typeset int_DispatcherPID=$(ls -l "${file_DispatchLock}" 2>/dev/null | awk -F"_" '{print $NF}')
  int_DispatcherPID=${int_DispatcherPID:-0}
  printf " %${int_TitleWidth}s|%${int_Column3Width}s|  %${int_TitleWidth}s|%${int_Column6Width}s|" \
         "${str_ProgramName} [${str_ProgramVersion}]" \
         "D:${int_DispatcherPID}" \
		 "${int_DiskUsage}" "${str_License}"
  tput cup 0 ${int_DatePut} ; echo "$(date +'%D %T')"


  # Reset the Array for Jobs and States
  # ===================================
  unset arr_Jobs arr_States
}
readonly -f fn_ShowTop

fn_ShowLine()
{
  # Show a line of dashes unless a dirrent character is past or character and title is passed
  
  # Check if parameters have been past
  # ==================================
  typeset local cha_LineChar=${1:-"-"}
  typeset local str_LineTitle=${2:-"${cha_LineChar}"}

  # Find the width of the title
  # ===========================
  typeset local int_LineTitleWidth=$(echo ${str_LineTitle} | wc -c)

  # Set the number of characters required to the correct width
  # ==========================================================
  (( int_DisplayWidth = ${int_ScreenWidth}-${int_LineTitleWidth} - 4 ))
  printf "${dis_Reset}   ${str_LineTitle} %${int_DisplayWidth}s\n" | sed "s/ /${cha_LineChar}/g"

}
readonly -f fn_ShowLine

fn_ShowJobs2()
{
  # Show job details for each job state past. The value passed is one or more directory names
  # =========================================================================================
  typeset local str_EachJobState=
  typeset local arr_JobList=
  typeset local str_StatusColour="${dis_Reset}"
  typeset local str_StatusColour=""

  # Due to the fact that directories may contain "spaces" so "cd" there first
  # =========================================================================
  cd "${dir_Job}"
  int_Count=1

  file_Cache=$(mktemp "${dir_Tmp}"/cache.$$.XXXXX)
  echo "#$$" > ${file_Cache}
  for str_State in ${@} ; do
    printf "${dis_Reset}"

    [[ "${str_State}" = "failed"  ]] && str_StatusColour="${dis_BRed}" || str_StatusColour="${dis_Reset}"
    [[ "$(ls ${str_State}/* 2>/dev/null)" ]] && fn_ShowLine "-" "$(echo ${str_State} | tr [:lower:] [:upper:])"
  	[[ "${str_State}" != "completed" ]] && str_Reverse="r" || str_Reverse=""
    ls -${str_Reverse}t "${str_State}/${str_JobPrefix}"* 2>/dev/null | grep -v "pause$" | gawk \
      -v            state=${str_State} \
      -v          linenum=${int_Count} \
      -v          dir_Log=${dir_Log} \
	  -v       dir_Active=${dir_Active} \
	  -v       file_Cache=${file_Cache} \
	  -v           Colour=${str_StatusColour} \
	  -v  int_ScreenWidth=${int_ScreenWidth} \
      -v int_Column1Width=${int_Column1Width} \
      -v int_Column2Width=${int_Column2Width} \
      -v int_Column3Width=${int_Column3Width} \
      -v int_Column4Width=${int_Column4Width} \
	  -v int_Column5Width=${int_Column5Width} \
      -v int_Column6Width=${int_Column6Width} \
      -v int_MaxShown=${int_MaxShown} 'BEGIN {
       FS = "_"
    }
    linenum <= int_MaxShown {
      #system("[[ grep str_Owner "$0" ]] && printf \"P|\" || printf \" |\"")
      printf Colour
	  system("[[ -r "dir_Active"/$(basename "$0").rules ]] && printf \"R\" || printf \" \"")
      printf "%3s", linenum
      system("[[ -r "dir_Active"/$(basename "$0").pause ]] && printf \"P|\" || printf \" |\"")

      if ( $2 != "" ) {
        printf "%7s|", $2   
      }
      else {
        printf "%7s|", substr($3,1,7)
      }
	  int_LogWidth=int_ScreenWidth - 7 - int_Column1Width - int_Column2Width - int_Column3Width \
                   - int_Column4Width  - int_Column5Width
# printf "${dis_Reset}${str_StatusColour}%${int_Column1Width}s "   "${int_Count}${str_ID}"
      printf "%"int_Column3Width"s|%"int_Column4Width"s|%"int_Column5Width"s|",$4,$5,$6
      system("tail -1 "dir_Log"/$(basename "$0").log 2>/dev/null | cut -c1-"int_LogWidth)
      system("echo arr_States["linenum"]="state" >> "file_Cache)
      system("echo arr_Jobs["linenum"]=$(basename "$0") >> "file_Cache)

      linenum++
    }
    END {
      system("echo int_Count="linenum" >> "file_Cache )
    }'
    #. ${file_Cache}
    [[ -r "${file_Cache}" ]] && . ${file_Cache} && rm "${file_Cache}"
  done
}
readonly -f fn_ShowJobs2

fn_FormatTasks()
{
  # This function is only called by fn_ShowTasks and will format the layout
  # regardless of whether the tasks were requested from a group call
  typeset local file_Job="${1}"
  printf "\n\n   "
  ls -lL "${file_Job}"  #"${dir_Job}"/${arr_States[${int_Answer}]}/${arr_Jobs[${int_Answer}]}
  printf "\n"
  cat "${file_Job}" | gawk 'BEGIN {
              linenum=1
            }
            $0 ~ "^fn_Task_[1-9]" { 
			  #print " "linenum, $2, $3, $4, NR, NF
			  int_Last=NF-7
			  if ( $3 != "&" ) {
			  printf "%4s : ",linenum
			  for ( x=2 ; x<int_Last ; x++ ) {printf " "$x}
              linenum++
			  printf "\n" }
            }

            END {
              printf "\n\n"
            }'
  fn_PressEnter
}
readonly -f fn_FormatTasks

fn_ShowTasks()
{
  # This functions simply displays the list of tasks that will be run
  # If a value was passed assume that was the job for which to show the tasks
  typeset local file_Job="${1}"
  typeset local int_Answer=

  fn_ShowTop
  fn_ShowLine

  if [[ "${file_Job}" ]] ; then
    fn_FormatTasks "${file_Job}"
  else
    printf "\n Display tasks for which job(s)?\n\n"

    fn_ShowJobs2 superseded starting failed running queued pending new completed
    fn_ShowLine
    fn_GetAnswer range
    str_Answer=$(fn_Range "${str_Answer}")
    if [ "${str_Answer}" != "x" ] ; then
      for int_Answer in ${str_Answer} ; do
        # awk replaces 
		#   grep "#${str_ProgramName}_Task" "${dir_Job}"/${arr_States[${int_Answer}]}/${arr_Jobs[${int_Answer}]} | rev | cut -d">" -f4- | rev | more
		fn_FormatTasks "${dir_Active}/${arr_Jobs[${int_Answer}]}"
      done
    else
      echo "Nothing chosen"
      fn_PressEnter
    fi
  fi
}
readonly -f fn_ShowTasks

fn_JobInfo()
{
      clear
      fn_ShowTop
      fn_ShowLine "-" "Owner"
      typeset local str_JobOwner=$(grep ^str_Owner "${file_ActiveJob}")
      echo " ${str_JobOwner}"
      echo ""
      fn_ShowLine "-" "File details"
      echo " State at selection : ${str_JobState}"
      echo ""
      ls -lL "${file_ActiveJob}"
      ls -lL "${file_Log}"
      echo ""
	  fn_ShowRules
	  fn_ShowLine "-" "Template"
	  sed -n -e '/^# Template Begin$/,/^# Template End$/{//!p}' "${file_ActiveJob}"
	  echo ""
      fn_ShowLine "-" "Log Summary"
      tail -10 "${file_Log}"
      echo ""
      fn_ShowLine "-" 
      printf "\n${dis_Reset}"
}

fn_ContextMenu()
{
  # A context-based menu based on the state of jobs
  # Used in two ways....
  #    specific mode (where a directory name is passed)
  # and
  #    generic mode (where is caters for all directories)
 
  typeset local str_State=${1:-}
  
  typeset local b_QueuedJobs=
  typeset local b_FailedJobs=
  typeset local b_NewJobs=
  typeset local b_RunningJobs=
#  printf "\n\n${dis_Reset}"
  if [[ "${str_State}" ]] ; then
    # Specific Mode
    printf " ${dis_ULOn}E${dis_ULOff}dit | ${dis_ULOn}L${dis_ULOff}og | "
    case ${str_State} in
      queued  ) b_QueuedJobs=1 ;;
      failed  ) b_FailedJobs=1 ;;
      new     ) b_NewJobs=1 ;;
      running ) b_RunningJobs=1 ;;
    esac
  else
    # Generic Mode
    printf " ${dis_ULOn}N${dis_ULOff}ew | "
	[[ "$(ls ${dir_Lock} 2>/dev/null)" ]] && printf "${dis_ULOn}L${dis_ULOff}ock | "
    [[ "$(echo ${arr_States[@]} | grep -i queued)"  ]] && b_QueuedJobs=1 
    [[ "$(echo ${arr_States[@]} | grep -i running)" ]] && b_RunningJobs=1 
    [[ "$(echo ${arr_States[@]} | grep -i new)"     ]] && b_NewJobs=1 
    [[ "$(echo ${arr_States[@]} | grep -i failed)"  ]] && b_FailedJobs=1 
  fi
  
  [[ "${b_QueuedJobs}" ]]                              && printf "${dis_ULOn}U${dis_ULOff}nqueue | "
  [[ "${b_RunningJobs}" ]] || [[ "${b_QueuedJobs}" ]]  && printf "${dis_ULOn}P${dis_ULOff}ause | "
  [[ "${b_FailedJobs}" ]]                              && printf "${dis_ULOn}R${dis_ULOff}esume | "
  [[ "${b_FailedJobs}" ]]  && [ "${str_State}" ]       && printf "${dis_ULOn}F${dis_ULOff}IP | ${dis_ULOn}S${dis_ULOff}kip | "
  [[ "${b_NewJobs}" ]]                                 && printf "${dis_ULOn}Q${dis_ULOff}ueue | "
  [[ "${str_State}" ]]                                 || printf "${dis_ULOn}M${dis_ULOff}OTD | "
  [[ "${arr_Jobs[1]}" ]]   || [[ "${str_State}" ]]     && printf "${dis_ULOn}T${dis_ULOff}asks | "

  printf "${dis_ULOn}C${dis_ULOff}SV | e${dis_ULOn}X${dis_ULOff}it : "
}
readonly -f fn_ContextMenu

# End
