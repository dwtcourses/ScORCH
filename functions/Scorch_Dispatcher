#
# Copyright 2015 WebMarcIT Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

# This file contains functions to set and display layout
# fn_Dispatcher
# fn_CheckDispatcher
# fn_RunJobs
# fn_LockManager

fn_Dispatcher()
{
  # echo $$
  typeset local file_DispatchLock="${dir_Lock}/${str_ProgramName}.lck"
  typeset local int_DispatchCount=0
  
  fn_CreateFile ${file_DispatchLog}
 # set | grep -i who
  if [[ ! -L ${file_DispatchLock} ]] ; then
    ln -s $(whoami)_$$ "${file_DispatchLock}"
  else
    rm "${file_DispatchLock}"
    #fn_CheckDispatcher
  fi
  while [ ${int_DispatchCount} -lt ${int_DispatchMax} ] ; do
    # Repair any missing lock file for dispatcher
    [[ ! -L ${file_DispatchLock} ]] && ln -s $(whoami)_$$ "${file_DispatchLock}"

    fn_CheckRunning
    # Check running jobs are really running
#    typeset local arr_RunningJobs=$(ls -rt1 "${dir_Running}")
#	if [[ "${arr_RunningJobs}" ]] ; then
#	  for file_EachJob in ${arr_RunningJobs} ; do
	    :
#ls -l ${dir_Running}/${file_EachJob}
#ps -ef | grep ${file_EachJob}
#      done
#    fi

    # Move queued jobs to start state
	typeset local arr_QueuedJobs=$(ls -rt1 "${dir_Queued}")
	if [[ "${arr_QueuedJobs}" ]] ; then
      for file_EachJob in ${arr_QueuedJobs} ; do
        str_QueueLock=$(echo "${file_EachJob}" | awk -F"_" '{print $4"_"$6}')
        file_QueueLock="${file_JobLock}.${str_QueueLock}"
  
        if [ ! -L "${file_QueueLock}" ] ; then
          ln -s "${file_EachJob}" "${file_QueueLock}"
          echo "$(date +"%D %T") Dispatch: ${file_EachJob}" >> "${file_DispatchLog}"
          mv "${dir_Queued}"/${file_EachJob} "${dir_Starting}"
		  #[[ -f "${dir_Queued}"/${file_EachJob}.pause ]] && mv "${dir_Queued}"/${file_EachJob}.pause "${dir_Running}"
		  int_DispatchCount=0
          sleep 1
        else
          # Check that for every env lock file that there is a job in a non finish state
          # (failed, completed, deleted, new)
          typeset local arr_JobLocks=$(ls "${file_JobLock}"*)
          for file_EachLock in ${arr_JobLocks} ; do
            [[ "$(find ${dir_Job}/running ${dir_Job}/starting -name $(ls -l "${file_EachLock}" | awk -F" " '{print $NF}'))" ]] || rm ${file_EachLock}
          done
          sleep 1
        fi
      done
    fi
	(( int_DispatchCount+=1 ))
    sleep 20
  done
  rm -f "${file_DispatchLock}"
  typeset int_DispatcherPID=0
  exit 0
}
readonly -f fn_Dispatcher

fn_CheckRunning()
{
  # Check running jobs are really running
  typeset local arr_RunningJobs=$(ls -t1 "${dir_Running}" | grep -v "pause$" 2>/dev/null)
  if [[ "${arr_RunningJobs}" ]] ; then
    for file_EachJob in ${arr_RunningJobs} ; do
	  if [ ! "$(ps -ef | grep ${file_EachJob} | grep -v grep)" ] ; then
        mv ${dir_Running}/${file_EachJob} ${dir_Failed}/.
        echo "ORPHANED:$(date "+%D %T"):Resume point:unknown" >> "${dir_Log}/${file_EachJob}.log"

      fi
    done
  fi
}
readonly -f fn_CheckRunning

fn_CheckDispatcher()
{
  # Check Dispatcher
  typeset local int_DispatcherPID=$(ls -l "${dir_Lock}/${str_ProgramName}.lck" 2>/dev/null | cut -d_ -f2)

  ps -p ${int_DispatcherPID} > /dev/null 2>&1 && return 0

  if $(ps -p ${int_DispatcherPID} > /dev/null 2>&1 ) ; then
    :
	#echo "Dispatcher ok"
  else
    rm "${dir_Lock}/${str_ProgramName}.lck" 2>/dev/null
    "${dir_Base}/${str_ProgramName}" -dispatcher -j ${dir_Job} >> ${file_DispatchLog} &
  fi
  # Make sure a dispatcher is running
  #echo "Lock dir: ${file_Lock}"
  # repair lock file or start a dispatcher  
  #echo "check this is running .... ${str_ProgramName} -dispatcher &"
}
readonly -f fn_CheckDispatcher

fn_RunJobs()
{
  # Run owned jobs in START state
  #ls "${dir_Starting}"
  #shopt -s nullglob
  for file_EachJob in $(ls -tr "${dir_Starting}"/* 2>/dev/null)  ; do
    echo "Starting $(basename "${file_EachJob}")"
    nohup "${file_EachJob}" </dev/null >> "${dir_Log}"/$(basename "${file_EachJob}").log 2>&1 &
	sleep 0.5
  done
}
readonly -f fn_RunJobs

fn_LockManager()
{
  # An easier way to check locks
  while : ; do
    fn_ShowTop
    fn_ShowLine
    int_Count=1
    for file_Lock in $(ls ${dir_Lock}) ; do
      printf "${dis_Reset}${str_StatusColour}%${int_Column1Width}s | "   "${int_Count}"
      printf "${file_Lock} -> $(ls -l ${dir_Lock}/${file_Lock} | cut -d ">" -f2)\n"
      arr_Locks[${int_Count}]="${file_Lock}"
      (( int_Count+=1 ))
    done
    fn_ShowLine "="

    printf "\n Select job number to delete | e${dis_ULOn}X${dis_ULOff}it : "

    read -t 10 char_Choice
    [[ "${char_Choice}" = "" ]] && char_Choice="x"
    case ${char_Choice} in

      # Lock transition
      d | D ) printf "rm lock "  ;;
	  [0-9]* ) echo removing ${dir_Lock}/${arr_Locks[${char_Choice}]} ; sleep 2 ; rm ${dir_Lock}/${arr_Locks[${char_Choice}]} ;;
      
      x | X ) break ;;
    esac
	fn_RunJobs
  done
}
readonly -f fn_LockManager
