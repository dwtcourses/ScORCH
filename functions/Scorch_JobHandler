#
# Copyright 2015 WebMarcIT Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

# fn_NewJob
# fn_JobHeader()
# fn_CheckTask()
# fn_JobFooter()
# fn_NewJob()
# fn_GetRequest()
# fn_ProcessRequest()
# fn_GetJobID()
# fn_ExtractPairs()
# fn_Transition()

fn_JobHeader()
{
  # Function to create and initialise the job file. This job file is incomplete without a Footer
  # Tasks are added via the "Task" function which is made available to the plugin
  #
  # The file to be created is passed as a variable

  typeset local file_Job=${1}
  echo "Creating ${file_Job}"
  #touch "${file_Job}"
  ln -s ${dir_Active}/$(basename ${file_Job}) ${file_Job}
  fn_CreateFile "${file_Job}" blank
  cat > "${file_Job}" << EOF
#!/bin/bash

    #####  ####  ####  #####   #### #    #
   #     #     #    # #    # #     #    #
   ###  #     #    # #####  #     ######
     # #     #    # #   #  #     #    #
#####  ####  ####  #    #  #### #    #

# Created: $(date)
# By: $(whoami)
# Using: ${str_ProgramName}[${str_ProgramVersion}]
#

# Audit
str_StartTime="\$(date +%s)"
str_Owner=$(whoami)

# Job settings
int_JobID=${int_JobID}
int_ResumePoint=
int_Last=0
str_JobName="\$(basename "\$0")"


# Directory locations
dir_Job="${dir_Job}"
dir_Running="${dir_Running}"
dir_Failed="${dir_Failed}"
dir_Completed="${dir_Completed}"
dir_Starting="${dir_Starting}"
dir_Pause="${dir_Active}"
dir_Active="${dir_Active}"
file_Log="${dir_Var}/log/\${str_JobName}.log"
LOCK="${file_JobLock}.${SYSTEM}_${str_EachENVIRONMENT}"
echo "AUDIT:PID:\$\$" >> "\${file_Log}" 
[[ ! -f "\${dir_Starting}"/\${str_JobName} ]] && echo "This is a ${str_ProgramName} script. Do not run these scripts manually unless you know what you are doing." && exit 1

[[ -w "\${dir_Starting}"/\${str_JobName} ]] && mv "\${dir_Starting}"/\${str_JobName} "\${dir_Running}"/.

# Check Tasks
fn_CheckTask()
{
  typeset local int_RC=\${1}
  typeset local int_Task=\${2}

  if [ \${int_RC} -ne 0 ] ; then
    mv "\${dir_Running}"/\${str_JobName} "\${dir_Failed}"/.
    echo "\$(${fn_LogDate}) +++Failed task \${int_Task}" >> "\${dir_Failed}"/\${str_JobName}
    echo "\$(${fn_LogDate}) +++Failed task. Resume point:\${int_Task}" >> "\${file_Log}"
    rm "\${LOCK}"
    exit 1
  else
    echo "\$(${fn_LogDate}) Completed task \${int_Task}/\${int_Last}" >> "\${file_Log}"
  fi

  # Checking if PAUSED
  if [ -f "\${dir_Pause}"/\${str_JobName}".pause" ] ; then
    mv "\${dir_Running}"/\${str_JobName} "\${dir_Failed}"/.
    rm "\${dir_Pause}"/\${str_JobName}".pause"
	(( int_Task+=1 ))
    echo "\$(${fn_LogDate}) Paused. Resume point:\${int_Task}" >> "\${dir_Failed}"/\${str_JobName}
    echo "\$(${fn_LogDate}) Paused. Resume point:\${int_Task}" >> "\${file_Log}"
    rm "\${LOCK}"
    exit 1
  fi
}

EOF
}
readonly -f fn_JobHeader

fn_JobFooter()
{
  # Function to add the processing power to a job file. This requires a JobHeader to have been run
  #
  # The file to be appended to is passed as a variable

  typeset local file_Job=${1}
  (( int_TaskCount-=1 ))

  # echo "Adding footer to ${file_Job}"
  cat >> "${file_Job}" << EOF

int_StartTask=\${int_ResumePoint:-1}
int_Last=${int_TaskCount}

while [ \${int_StartTask} -le \${int_Last} ] ; do
  echo "===================" >> "\${file_Log}"
  echo "\$(${fn_LogDate}) Starting Task[\${int_StartTask}/\${int_Last}]" >> "\${file_Log}"
  declare -f fn_Task_\${int_StartTask} | tail -n +3 | head -n -2 >> "\${file_Log}"
  fn_Task_\${int_StartTask}
  (( int_StartTask+=1 ))
done

mv "\${dir_Running}"/\${str_JobName} "\${dir_Completed}"/.
rm "\${LOCK}"

int_FailureCount=\$(egrep "[0-9]{6}-[0-9]{6}.+++Failed task" "\${dir_Completed}"/\${str_JobName} | wc -l)
#(( int_FailureCount+=0 ))
echo "\$(${fn_LogDate}) COMPLETED:\${int_StartTask}" >> "\${dir_Completed}"/\${str_JobName}
echo "AUDIT:FINISH:\$(date "+%s")" >> "\${file_Log}"
echo "\$(${fn_LogDate}) Tasks[\${int_Last}] Failures[\${int_FailureCount}]" >> "\${file_Log}"
# CSV File
# Request time,Response time, Start time, End Time, Job name, number of failures, who
 int_Created=\$(grep -m 1 "Created by:" \${file_Log} | cut -d" " -f1)
 str_Requested=${FROM:-${int_Responded}}
 int_Start=\$(grep  "^AUDIT:START"  \${file_Log} | tail -1 | cut -d: -f3)
 int_Finish=\$(grep "^AUDIT:FINISH" \${file_Log} | tail -1 | cut -d: -f3) 
 (( int_Duration = int_Finish - int_Start ))
 echo \${str_Requested},\${int_Created},\${int_Start},\${int_Finish},\${str_JobName},\${int_Duration},\${int_Last},\${int_FailureCount},\${str_Owner} >> "${file_CSV}"
touch -h "\${dir_Completed}/\${str_JobName}" # To reflect the correct finish time in the file
exit 0

EOF

  echo "# Template Used" >> "${file_Job}"
  echo "=============================" >> "${file_Job}"
  cat "${file_Request}" >> "${file_Job}"
  echo "=============================" >> "${file_Job}"
  chmod 770 "${file_Job}"
}
readonly -f fn_JobFooter

fn_NewJob()
{
  fn_ShowTop
  fn_ShowLine "-"
  fn_LoadFunctions ${dir_Plugins} "SP_"

  fn_GetRequest "${file_Template}"
  fn_ProcessRequest
  fn_CheckDispatcher

  rm "${file_Request}"
}
readonly -f fn_NewJob

fn_GetRequest()
{
  # Receive the request from a file or interactively
  typeset local file_Template="${1:-}"
  typeset local str_Line=""
  typeset local int_GetCount=1

  # global tmp file
  file_Request=${dir_Tmp}/${str_ProgramName}.$$
  file_Request2=${dir_Tmp}/${str_ProgramName}.$$.${int_GetCount}

  if [ ! -z "${file_Template}" ] ; then
    echo "$($fn_LogDate): Processing file:${file_Template}"
    while read str_Line ; do
      echo ${str_Line} | grep ":" >> ${file_Request}
    done < "${file_Template}"
  else
    printf "\n help <plugin>    at any time for additional parameters\n\n"
    printf " Please enter the request below.\n To complete the request is use a fullstop on a newline:\n\n"
    while [[ "${str_Line}" != "." ]] ; do
      read str_Line
      if [[  "${str_Line}" =~ "help" ]] ; then
        typeset local str_Help=${str_Line#help }
        if [[ "${str_Line}" ]] ; then
          echo "==SYSTEM============="
		  declare -f fn_ExtractPairs | grep "GetVar -pattern"
		  echo "==CUSTOM============="
          declare -f "SP_${str_Help}" | grep "GetVar "
          echo "==============="
        fi
      else
        printf "${str_Line}" | grep ":" >> "${file_Request}"
      fi
    done
  fi
}
readonly -f fn_GetRequest

fn_ProcessRequest()
{
  typeset local int_JobCount=1
  fn_GetJobID
  fn_ExtractPairs
  
  [[ "${b_Debug}" ]] && echo "Action: ${ACTION}"
  for str_EachACTION in ${ACTION} ; do
    for str_EachENVIRONMENT in ${ENVIRONMENT} ; do

	  int_TaskCount=0
	  if type -t SP_${SYSTEM}_${str_EachACTION} >/dev/null ; then
        fn_Call="SP_${SYSTEM}_${str_EachACTION}"
      else
		fn_Call="SP_${str_EachACTION}"
		if type -t ${fn_Call} >/dev/null ; then
		  printf "\n\nBest practice is to use SYSTEM..\n"
		else
          printf "\n\nCannot find a function called SP_${SYSTEM}_${str_EachACTION} or ${fn_Call}\n"
		  fn_PressEnter
		  return 0
        fi
      fi
      str_Call=${fn_Call#SP_}
      file_Job="${dir_New}"/${str_JobPrefix}${TICKET}_${int_JobID}.${int_JobCount}_${str_Call}_${str_EachENVIRONMENT}_${RELEASE}
      fn_JobHeader "${file_Job}"
      Task "echo AUDIT:START:\${str_StartTime}"

      echo "$(${fn_LogDate}) Plugin:${str_Call}" >> "${dir_Log}"/$(basename "${file_Job}").log
      eval "${fn_Call}"
      if [[ $? -ne 0 ]] ; then
        echo "$(${fn_LogDate}) Error in plugin" >> "${dir_Log}"/$(basename "${file_Job}").log
		mv ${file_Job} ${dir_Failed}/.
		fn_PressEnter
        exit 1
      fi

      fn_JobFooter "${file_Job}"
      echo "$(${fn_LogDate}) Created by:$(whoami) Tasks[${int_TaskCount}]" >> "${dir_Log}"/$(basename "${file_Job}").log
      (( int_JobCount+=1 ))

      # If there is already another job in a failed state, mv that failed job to the superceeded directory
      if [[ $(ls "${dir_Failed}"/${str_JobPrefix}*_${SYSTEM}_${ENVIRONMENT}_${str_EachACTION}_* 2>/dev/null)  ]] ; then
        mv "${dir_Failed}"/${str_JobPrefix}*_${SYSTEM}_${ENVIRONMENT}_${str_EachACTION}_* "${dir_Superceeded}"/.
      fi
	  [[ ${b_Start} ]] && mv "${file_Job}" "${dir_Queued}/." 
    done
  done
}
readonly -f fn_ProcessRequest

fn_GetJobID()
{
  file_JobID="${dir_Var}"/JobID
  [[ ! -f "${file_JobID}" ]] && echo "BROKEN" && fn_CreateFile "${file_JobID}"
  
  typeset local file_JobIDLock="${file_JobID}".lock

  if ( set -o noclobber; > "${file_JobIDLock}") 2> /dev/null ; then
    if [ -r "${file_JobID}" ] ; then
      int_JobID=$(cat "${file_JobID}")
    else
      int_JobID=0
    fi
    (( int_JobID+=1 ))
    echo ${int_JobID} > "${file_JobID}"
    rm -f "${file_JobIDLock}"
  else
    echo "Could not get exclusive lock"
    exit 1
  fi
}
readonly -f fn_GetJobID

fn_ExtractPairs()
{
  GetVar -pattern "System"  -name SYSTEM             -default ""
  GetVar -pattern "Action"  -name ACTION      -list
  GetVar -pattern "Release" -name RELEASE            -default "NO-REL"
  GetVar -pattern "Enviro"  -name ENVIRONMENT -list  -default "NO-ENV"
  GetVar -pattern "Type"    -name TYPE               -default ""
  GetVar -pattern "Ticket"  -name TICKET             -default ""
  
  [[ "${SYSTEM}" = "" ]] && SYSTEM=$(echo $ACTION | cut -d"_" -f1) && ACTION=$(echo $ACTION | cut -d"_" -f2)
  #echo $SYSTEM and $ACTION ; sleep 4
}
readonly -f fn_ExtractPairs

Task()
{
  # Exception to the naming convention is Task. This is used in plugins by the users
  # 
  # This function will Add Tasks to a scorch Job
  # ================================================================================
  int_TaskCount=${int_TaskCount:-0}
  typeset local str_Task1=${1}
  typeset local str_OR=${2}
  typeset local str_Task2=${3}
  typeset local str_AltTask=

  [[ "${str_OR}" = "OR" ]] && [[ "${str_Task2}" != "" ]] && str_AltTask="|| ${str_Task2} >> \"\${file_Log}\" 2>&1" >> ${file_Job}
  printf "fn_Task_${int_TaskCount}(){ ${str_Task1}\t>> \"\${file_Log}\" 2>&1 ${str_AltTask} ; fn_CheckTask \$? \${int_StartTask};}\t#${str_ProgramName}_Task\n" >> "${file_Job}"

  (( int_TaskCount+=1 ))
}
readonly -f Task

GetVar()
{
  # Exception to the naming convention is GetVar. This is used in plugins by users
  #
  # This function is used to set global variables with value pairs from templates
  # =============================================================================
  #
  # Given    KEYNAME : VALUE
  # In a template, 
  # 
  # -label  "<key name>"          specifies the key name search string
  # -name   "<variable name>"  the global variable to assign the VALUE to
  # -c                         Enforce case in the label pattern
  # -default "<value>"         Set a default is no value passed
  # -list                      Expect a list of values into an array by space or comma
  #
  # awk 20070501 does not allow ignorecase so dont worry if it doesnt work
  # Examples
  #
  # GetVar -pattern "data label" -name DATA_LABEL -d "None"
  typeset local str_Pattern=
  typeset local str_Name=
  typeset local str_Value=
  typeset local str_Default=
  typeset local b_IgnoreCase=1
  typeset local b_List=
  
  if [ $# -ne 0 ] ; then
    while [ $# -gt 0 ] ; do
      case "${1}" in
        -pattern ) shift ; str_Pattern="${1}" ;;
        -name    ) shift ; str_Name="${1}"    ;;
        -default ) shift ; str_Default="${1}" ;;
        -c       )         b_IgnoreCase=0     ;;
        -list    )         b_List=1           ;;
      esac
      shift
    done
  fi

  # Awk is a pain if the items are in a list so handle lists separately
  # ===================================================================
  if [ "${b_List}" ] ; then
    #echo "ListPattern : ${str_Pattern} Name: ${str_Name}"
    str_Value="$(awk 'BEGIN {
       FS=":"
       IGNORECASE='"$b_IgnoreCase"' }
       $1 ~ /^ *'"$str_Pattern"'/ {print $2}'       "${file_Request}" | sed -e 's/[,&]/ /g' )"
  else
    str_Value="$(awk 'BEGIN {
       FS=":"
       IGNORECASE='"$b_IgnoreCase"' }
       $1 ~ /^ *'"$str_Pattern"'/ {gsub (/[ \t]+/, "");
         $2=$2;
         print $2}'       "${file_Request}" )" 
  fi

  # If a value hasnt been found or is empty, use the default if one is set
  # ======================================================================
  #echo "String is ${str_Value}"
  [[ "${str_Value}" ]] || str_Value=${str_Default}
  eval "${str_Name}=\"${str_Value}\""
}
readonly -f GetVar

fn_Transition()
{
  # Transition a job to a new state
  # ===============================

  typeset local str_Transition="${1}"
  fn_ShowTop
  printf "\n\nSelect jobs to move to $1 state\n\n"

  case ${str_Transition} in

    # Jobs requiring the dispatcher
    queue   ) fn_ShowJobs2 failed new   ; fn_CheckDispatcher ; str_Target="${dir_Queued}" ;;
    resume  ) fn_ShowJobs2 failed       ; fn_CheckDispatcher ; str_Target="${dir_Queued}" ;;

    # Jobs not requiring the dispatcher
    delete  ) fn_ShowJobs2 failed new          ; str_Target="${dir_Deleted}" ;;
    unqueue ) fn_ShowJobs2 failed starting queued     ; str_Target="${dir_New}"     ;;
	pause   ) fn_ShowJobs2 running starting queued    ; str_Target="${dir_Active}}" ;;

  esac

  fn_ShowLine
  fn_GetAnswer range
  arr_Answer=$(fn_Range ${str_Answer})
  # echo ">${arr_Answer}<"
  if [ "${arr_Answer}" != "x " ] ; then
    for str_EachAnswer in ${arr_Answer} ; do
	  typeset local file_Job="${dir_Job}"/${arr_States[${str_EachAnswer}]}/${arr_Jobs[${str_EachAnswer}]}
      typeset local file_Log="${dir_Log}/$(basename ${file_Job})".log

	  fn_Audit "${file_Job}" "$(basename ${str_Target})"
      case ${str_Transition} in 
        queue   ) fn_UpdateResumePoint "${file_Job}" 0 ; mv "${file_Job}" "${str_Target}"/. ;;
		unqueue ) mv "${file_Job}" "${str_Target}"/. ;;
        delete  ) mv "${file_Job}" "${str_Target}"/. ;;
        resume  ) fn_UpdateResumePoint "${file_Job}" "$(( $(fn_GetResumePoint ${file_Log}) ))"  ; mv "${file_Job}" "${str_Target}"/.    ;;
		pause   ) touch "${dir_Active}"/$(basename ${file_Job}).pause ;;
       # Cannot skip multiple jobs # s | S ) fn_UpdateResumePoint "${file_Job}" "$(( $(fn_GetResumePoint ${file_Log}) + 1 ))"  ;;
      esac
      
    done
  fi
}
readonly -f fn_Transition