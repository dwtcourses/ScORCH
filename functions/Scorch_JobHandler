##
## Copyright 2016 WebMarcIT Ltd
##
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
##    http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##

## These functions handle aspects or creating and processing new jobs, tasks and task groups
## fn_NewJob()
## fn_JobHeader()
## fn_CheckTask()
## fn_JobFooter()
## fn_NewJob()
## fn_GetRequest()
## fn_GetRequestor()
## fn_GetSent()
## fn_ProcessRequest()
## fn_GetJobID()
## fn_ExtractPairs()
## StartGroup
## EndGroup
## Task()
## tryTask()
## pauseTask()
## breakTask()
## GetVar()
## fn_Transition()
## fn_CheckOwnJobs()
## fn_SetJobOwner()
## fn_CheckOwner()



fn_JobHeader()
{
  ## Function to create and initialise the job file. This job file is incomplete without a Footer
  ## Tasks are added via the "Task" function which is made available to the plugin
  ##
  ## The file to be created is passed as a variable

  typeset local file_Job=${1}
  echo "Creating ${file_Job}"
  fn_CreateFile "${dir_Active}/$(basename ${file_Job})" blank
  ln -s "${dir_Active}/$(basename "${file_Job}")" "${file_Job}"
  cat > "${file_Job}" << EOF
#!/bin/bash

#     #####        ####  #####   #### #    #
#    #      #### #    # #    # #     #    #
#    ###  #     #    # #####  #     ######
#      # #     #    # #   #  #     #    #
# #####  ####  ####  #    #  #### #    #

# Created: $(date)
# By: ${str_User}
# Using: ${str_ProgramName}[${str_ProgramVersion}]

# Audit
str_StartTime="\$(date +%s)"
str_Owner=${str_User}

# Job settings
int_JobID=${int_JobID}
int_ResumePoint=
int_Last=0
str_JobName="\$(basename "\$0")"


# Directory locations
dir_Job="${dir_Job}"
dir_Running="${dir_Running}"
dir_Failed="${dir_Failed}"
dir_Completed="${dir_Completed}"
dir_Manual="${dir_Manual}"
dir_Starting="${dir_Starting}"
dir_Pause="${dir_Active}"
dir_Active="${dir_Active}"
file_Log="${dir_Var}/log/\${str_JobName}.log"
LOCK="${file_JobLock}.${ACTION}_${ENVIRONMENT}"
echo "AUDIT:PID:\$\$" >> "\${file_Log}" 
[[ ! -f "\${dir_Starting}"/\${str_JobName} ]] && echo "This is a ${str_ProgramName} script. Do not run these scripts manually unless you know what you are doing." && exit 1

# ADD TICKETING START TRANSITION/SYSTEM HERE

[[ -w "\${dir_Starting}"/\${str_JobName} ]] && mv "\${dir_Starting}"/\${str_JobName} "\${dir_Running}"/.

# Check Tasks
fn_CheckTask()
{
  typeset local int_RC=\${1}
  typeset local int_Task=\${2}

  if [ \${int_RC} -ne 0 ] ; then
    mv "\${dir_Running}"/\${str_JobName} "\${dir_Failed}"/.
    echo "\$(${fn_LogDate}) +++Failed task \${int_Task}" >> "\${dir_Failed}"/\${str_JobName}
    echo "\$(${fn_LogDate}) +++Failed task. Resume point:\${int_Task}" >> "\${file_Log}"
    rm "\${LOCK}" 2>/dev/null
    exit 1
  else
    echo "\$(${fn_LogDate}) Completed task [\${int_Task}/\${int_Last}]" >> "\${file_Log}"
  fi

  # Checking if PAUSED
  if [ -f "\${dir_Pause}"/\${str_JobName}".pause" ] ; then
    if [[ \${int_Task} = \${int_Last} ]] ; then
      echo "\$(${fn_LogDate}) Last Task already. Cannot paused from task:\${int_Task}" >> "\${file_Log}"
      rm "\${dir_Pause}"/\${str_JobName}".pause"
    else
      mv "\${dir_Running}"/\${str_JobName} "\${dir_Failed}"/.
      rm "\${dir_Pause}"/\${str_JobName}".pause"
      (( int_Task+=1 ))
      echo "\$(${fn_LogDate}) Paused. Resume point automatically set for resume:\${int_Task}" >> "\${dir_Failed}"/\${str_JobName}
      echo "\$(${fn_LogDate}) Paused. Resume point automatically set for resume:\${int_Task}" >> "\${file_Log}"
      rm "\${LOCK}" 2>/dev/null
      exit 1
	fi
  fi
}

fn_NiceTime()
{
  local hours= minutes= seconds=
  ((hours=\${1}/3600))
  ((minutes=\${1}%3600/60))
  ((seconds=\${1}%60))
  printf "%02dh %02dm %02ds\n" \$hours \$minutes \$seconds
}

EOF
}
readonly -f fn_JobHeader

fn_JobFooter()
{
  ## Function to add the processing power to a job file. This requires a JobHeader to have been run
  ##
  ## The file to be appended to is passed as a variable

  typeset local file_Job="${1}"
  (( int_TaskCount-=1 ))

  ## echo "Adding footer to ${file_Job}"
  cat >> "${file_Job}" << EOF

int_StartTask=\${int_ResumePoint:-1}
int_Last=${int_TaskCount}

while (( int_StartTask <= int_Last )) ; do
  echo "===================" >> "\${file_Log}"
  echo "\$(${fn_LogDate}) Starting task [\${int_StartTask}/\${int_Last}]" >> "\${file_Log}"
  declare -f fn_Task_\${int_StartTask} | tail -n +3 | head -n -2 >> "\${file_Log}"
  fn_Task_\${int_StartTask}
  (( int_StartTask+=1 ))
done
echo "===================" >> "\${file_Log}"

echo "\$(${fn_LogDate}) COMPLETED:\${int_StartTask}" >> "\${dir_Running}"/\${str_JobName}
mv "\${dir_Running}"/\${str_JobName} "\${dir_Completed}"/.
rm "\${LOCK}" 2>/dev/null

int_FailureCount=\$(egrep "[0-9]{6}-[0-9]{6}.+++Failed task" "\${dir_Completed}"/\${str_JobName} | wc -l)
int_ManualCount=\$(egrep "[0-9]{6}-[0-9]{6}.+++Manual task" "\${dir_Completed}"/\${str_JobName} | wc -l)
#(( int_FailureCount+=0 ))
echo "AUDIT:FINISH:\$(date "+%s")" >> "\${file_Log}"

# CSV File
# Request time,Response time, Start time, End Time, Job name, number of failures, who
int_Created=\$(grep -m 1 "Created by:" \${file_Log} | cut -d" " -f1)
str_Requested=${FROM:-${int_Responded}}
int_Start=\$(grep  "^AUDIT:START"  \${file_Log} | tail -1 | cut -d: -f3)
int_Finish=\$(grep "^AUDIT:FINISH" \${file_Log} | tail -1 | cut -d: -f3) 
(( int_Duration = int_Finish - int_Start ))

printf "\$(${fn_LogDate}) Tasks[\${int_Last}] Time[\$(fn_NiceTime \${int_Duration})] " >> "\${file_Log}"
(( int_ManualCount  > 0 )) && printf "Manual tasks[\${int_ManualCount}]"               >> "\${file_Log}"
(( int_FailureCount > 0 )) && printf "Failures[\${int_FailureCount}]"                  >> "\${file_Log}"
printf "\n" >> "\${file_Log}"

echo \${str_Requested},\${int_Created},\${int_Start},\${int_Finish},\${str_JobName},\${int_Duration},\${int_Last},\${int_FailureCount},\${str_Owner} >> "${file_CSV}"
touch -h "\${dir_Completed}/\${str_JobName}" # To reflect the correct finish time in the file

#fn_NiceTime \$(( \${int_Finish} - \${int_Start}))

# ADD TICKETING CLOSE/SYSTEM HERE

exit 0

EOF

  echo "# Template Begin" >> "${file_Job}"
  cat "${file_Request}" >> "${file_Job}"
  echo "# Template End" >> "${file_Job}"
  chmod 770 "${file_Job}"
}
readonly -f fn_JobFooter

fn_GetRequestor() { : ; } ; readonly -f fn_GetRequestor
fn_GetSent() { : ; } ; readonly -f fn_GetSent

fn_NewJob()
{
  fn_ShowTop
  fn_ShowLine "-"
  fn_LoadFunctions "${dir_Plugins}" "SP_"
  fn_GetRequest "${file_Template}"
  fn_GetRequestor
  fn_GetSent
  fn_ProcessRequest
  fn_CheckDispatcher
}
readonly -f fn_NewJob

fn_GetRequest()
{
  ## Receive the request from a file or interactively
  typeset local file_Template="${1:-}"
  typeset local str_Line=""
  typeset local int_GetCount=1

  ## global tmp file
  file_Request=${dir_Tmp}/${str_ProgramName}.$$.${int_GetCount}
  fn_CreateFile "${file_Request}"

  if [ ! -z "${file_Template}" ] ; then
    echo "$($fn_LogDate): Processing file:${file_Template}"
    while read -r str_Line ; do
	  str_ULine=$(echo ${str_Line} | tr [:lower:] [:upper:])
      [[ ${str_ULine} =~ ACTION ]] &&  (( int_GetCount+=1 )) && file_Request=${dir_Tmp}/${str_ProgramName}.$$.${int_GetCount}
      echo "${str_Line}" | grep ":" >> "${file_Request}"
    done < "${file_Template}"
  else
    printf "\n help <plugin>    at any time for additional parameters\n\n"
    printf " Please enter the request below.\n To complete the request is use a fullstop on a newline:\n (To quit type CANCEL)\n\n"
    while [[ "${str_Line}" != "." ]] ; do
      read -r str_Line
	    str_ULine=$(echo ${str_Line} | tr [:lower:] [:upper:])
      if [[  ${str_ULine} =~ HELP ]] ; then
        typeset local str_Help=${str_Line#help }
        if [[ "${str_Line}" ]] ; then
          echo "==SYSTEM============="
          declare -f fn_ExtractPairs | grep "GetVar -pattern"
          echo "==CUSTOM============="
          declare -f "SP_${str_Help}" | grep "GetVar "
          echo "==============="
        fi
      else
	    [[ ${str_ULine} =~ CANCEL ]] && rm ${dir_Tmp}/${str_ProgramName}.$$.[0-9]* && break
        [[ ${str_ULine} =~ ACTION ]] &&  (( int_GetCount+=1 )) && file_Request=${dir_Tmp}/${str_ProgramName}.$$.${int_GetCount}
        echo "${str_Line}" | grep ":" >> "${file_Request}"
      fi
    done
  fi
}
##Enterprise feature available readonly -f fn_GetRequest

fn_ProcessRequest()
{
  typeset local int_JobCount=1
  typeset local int_FileCount=1

  int_JobID=$(fn_GetJobID)
  # Multi Action is enterprise feature
  ls ${dir_Tmp}/${str_ProgramName}.$$.*
  for str_EachFile in ${dir_Tmp}/${str_ProgramName}.$$.* ; do
    [[ -e ${str_EachFile} ]] || break
    file_Request=${dir_Tmp}/${str_ProgramName}.$$.${int_FileCount}
    echo "${str_EachFile}"
	
    fn_ExtractPairs
    b_Debug=1
    [[ "${b_Debug}" ]] && echo "Action List: ${ACTION_LIST}"
    for ACTION in ${ACTION_LIST} ; do
	    #echo "$ACTION is"
	
      for ENVIRONMENT in ${ENVIRONMENT_LIST} ; do

        int_TaskCount=0
        if type -t "SP_${ACTION}" >/dev/null ; then
          fn_Call="SP_${ACTION}"
        else
          printf "\n\nCannot find a function called SP_${ACTION}\n"
          fn_PressEnter
          return 0
        fi
        str_Call=${fn_Call#SP_}
        [[ ! -z "${LABEL}" ]]  && str_Label="${LABEL}" || str_Label="${ACTION}"
        file_Job="${dir_New}"/${str_JobPrefix}${TICKET}_${int_JobID}.${str_Label}.${int_JobCount}_${str_Call}_${ENVIRONMENT}_${RELEASE}
        fn_JobHeader "${file_Job}"
        Task "echo AUDIT:START:\${str_StartTime}"

        echo "$(${fn_LogDate}) Plugin:${str_Call}" >> "${dir_Log}"/$(basename "${file_Job}").log
        eval "${fn_Call}"
        if [[ $? -ne 0 ]] ; then
          echo "$(${fn_LogDate}) Error in plugin" >> "${dir_Log}"/$(basename "${file_Job}").log
          mv "${file_Job}" "${dir_Failed}"/.
          fn_PressEnter
          exit 1
        fi

        fn_JobFooter "${file_Job}"
        echo "$(${fn_LogDate}) Created by:${str_User} Tasks[${int_TaskCount}]" >> "${dir_Log}"/$(basename "${file_Job}").log
        (( int_JobCount+=1 ))

        if [[ $(ls "${dir_Failed}"/"${str_JobPrefix}*_${ACTION}_${ENVIRONMENT}*" 2>/dev/null)  ]] ; then
           mv "${dir_Failed}"/"${str_JobPrefix}*_${ACTION}_${ENVIRONMENT}*"   "${dir_Superseded}"/.
        fi
        [[ ${b_Start} ]] && mv "${file_Job}" "${dir_Queued}/." 

      done
    done
    (( int_FileCount++ ))
    rm "${file_Request}"
  done
}
## Enterprise features available readonly -f fn_ProcessRequest

fn_GetJobID()
{
  file_JobID="${dir_Var}"/JobID.${str_ProgramName}
  [[ ! -f "${file_JobID}" ]] && echo "Creating JobID file" && fn_CreateFile "${file_JobID}"
  
  typeset local file_JobIDLock="${file_JobID}".lock

#  if ( set -o noclobber; > "${file_JobIDLock}") 2> /dev/null ; then
#    if [ -r "${file_JobID}" ] ; then
#      int_JobID=$(cat "${file_JobID}")
#    else
#      int_JobID=0
#    fi
#    (( int_JobID+=1 ))
#    echo ${int_JobID} > "${file_JobID}"
#    rm -f "${file_JobIDLock}"
#  else
#    echo "Could not get exclusive lock"
#    exit 1
#  fi

  (
    flock -w 1 200
    #cat $file_JobID
    if [ -r "${file_JobID}" ] ; then
      int_JobID=$(cat "${file_JobID}")
    else
      int_JobID=0
    fi
    (( int_JobID+=1 ))
    echo ${int_JobID} > "${file_JobID}"
    echo ${int_JobID}
  ) 200> "${file_JobIDLock}"
}
readonly -f fn_GetJobID

fn_ExtractPairs()
{
  GetVar -pattern "From"    -name FROM
  GetVar -pattern "Sent"    -name SENT
  GetVar -pattern "Action"  -name ACTION_LIST
  GetVar -pattern "Release" -name RELEASE                -default ""
  GetVar -pattern "Enviro"  -name ENVIRONMENT_LIST -list -default "NA"
  GetVar -pattern "Type"    -name TYPE                   -default ""
  GetVar -pattern "Ticket"  -name TICKET                 -default "ID-${int_JobID}"  
}
## Enterprise feature available readonly -f fn_ExtractPairs

StartGroup()
{
  b_Background="&"
  arr_PIDs=""
  if [[ ${b_StartGroup} = "" ]] ; then
	printf '
	
typeset local int_PID=
typeset arr_PIDs=
	
fn_GroupWait()
{
  while : ; do
    arr_PIDsRemaining=
    for int_PID in ${arr_PIDs} ; do
      if kill -0 ${int_PID} 2>/dev/null ; then
        : # PID is still running
		echo "PID <${int_PID}> is still running"
        arr_PIDsRemaining="${arr_PIDsRemaining} ${int_PID}"  
      elif wait ${int_PID} ; then
        : # PID exited cleanly
	    echo "PID <${int_PID}> completed"
      else
        int_PID_RC=$?
   	    echo "PID <${int_PID}> completed with ${int_PID_RC}" >> "${file_Job}"
      fi
    done
    [[ ${#arr_PIDsRemaining} -eq 0 ]] && break
    arr_PIDs=${arr_PIDsRemaining}
	echo "Remaining PIDs : ${#arr_PIDS}"
    sleep 5
  done
}

' >> "${file_Job}"
	printf "fn_GroupWait()\n{\n  wait\n  echo \"\${arr_PIDs}\" >> \"\${file_Log}\"\n}\n" >> "${file_Job}"
	b_StartGroup=1
  fi
  int_SubTask=0
}

EndGroup()
{
  printf "fn_Task_${int_TaskCount}(){ fn_GroupWait\t>> \"\${file_Log}\" 2>&1 ; fn_CheckTask \$? \${int_StartTask};}\t#${str_ProgramName}_Task\n" >> "${file_Job}"
  b_Background=
  (( int_TaskCount++ ))
  int_SubTask=0
}

Task()
{
  ## Exception to the naming convention is Task. This is used in plugins by the users
  ## 
  ## This function will Add Tasks to a scorch Job
  ## ================================================================================
  int_TaskCount=${int_TaskCount:-0}
  typeset local   str_Task1=${1}
  typeset local      str_OR=${2}
  typeset local   str_Task2=${3}
  typeset local str_AltTask=

  [[ "${str_OR}" = "OR" ]] && [[ "${str_Task2}" != "" ]] && str_AltTask="|| ( ${str_Task2} ) >> \"\${file_Log}\" 2>&1" >> "${file_Job}"
  ##[[ "${b_StartGroup}" ]] && (( int_SubTask++ )) && str_SubTask=".${int_SubTask}" 

 if [[ "${b_Background}" ]] ; then
    ## The task is part of a group
    ((  int_SubTask++ ))
    str_GroupTask="_SubTask"
    printf "fn_Task_${int_TaskCount}(){ fn_Task_${int_TaskCount}${str_GroupTask} &
    arr_PIDs=\"\${arr_PIDs} \$!\" ;}\t#${str_ProgramName}_SubTask\n" >> "${file_Job}"
    str_LogExtension=".${int_SubTask}"
  else
    ## The task is a standard Task
    str_GroupTask=""
    str_LogExtension=""

  fi
  printf "fn_Task_${int_TaskCount}${str_GroupTask}(){ ${str_Task1} \t>> \"\${file_Log}${str_LogExtension}\" 2>&1 ${str_AltTask} ; fn_CheckTask \$? \${int_StartTask};}\t#${str_ProgramName}_Task\n" >> "${file_Job}"
  ##else
  ##  printf "fn_Task_${int_TaskCount}"
  ##fi
  (( int_TaskCount++ ))
}
readonly -f Task


tryTask()
{
  ## To make things simple if there was just one parameter passed, use Task "command" OR true
  Task "$*" OR true
}

pauseTask()
{
  ## Expection to the naming convention is pauseTask. This is used in plugins by users
  int_Sleep=${1:-10}
  Task "printf \"Sleeping for ${int_Sleep} seconds\n\" ; sleep ${int_Sleep}" 
}

breakTask()
{
  ## Exception to the naming convention is breakTask. This is used in plugins by users to force an exit
  Task "printf \"$*\\nForcing interrupt. Skip this task to continue.  \" ; [ 0 = 1 ]" 
}

GetVar()
{
  # Exception to the naming convention is GetVar. This is used in plugins by users
  #
  # This function is used to set global variables with value pairs from templates
  # =============================================================================
  #
  # Given    KEYNAME : VALUE
  # In a template, 
  # 
  # -label  "<key name>"          specifies the key name search string
  # -name   "<variable name>"  the global variable to assign the VALUE to
  # -c                         Enforce case in the label pattern
  # -default "<value>"         Set a default is no value passed
  # -list                      Expect a list of values into an array by space or comma
  #
  # awk 20070501 does not allow ignorecase so dont worry if it doesnt work
  # Examples
  #
  # GetVar -pattern "data label" -name DATA_LABEL -d "None"
  typeset local str_Pattern=
  typeset local str_Name=
  typeset local str_Value=
  typeset local str_Default=
  typeset local b_IgnoreCase=1
  typeset local b_List=
  typeset local b_Upper=
  typeset local b_Lower=
 
  if [ $# -ne 0 ] ; then
    while [ $# -gt 0 ] ; do
      case "${1}" in
        -pattern ) shift ; str_Pattern="${1}" ;;
        -name    ) shift ; str_Name="${1}"    ;;
        -default ) shift ; str_Default="${1}" ;;
        -c       )         b_IgnoreCase=0     ;;
        -list    )         b_List=1           ;;
        -upper   )         b_Upper=1          ;;
        -lower   )         b_Lower=1          ;;
      esac
      shift
    done
  fi

  ## Awk is a pain if the items are in a list so handle lists separately
  ## ===================================================================
  if [ "${b_List}" ] ; then
    ## Lists can be passed as a space, comma or ampersand separated list 
	## i.e. KEYWORD : ENV1, ENV2 ENV3 & ENV4
    str_Value="$(${cmd_AWK} 'BEGIN {
       FS=":"
       IGNORECASE='"$b_IgnoreCase"' }
       $1 ~ /^ *'"$str_Pattern"'/ {print $2}'       "${file_Request}" | sed -e 's/[,&]/ /g' )"
  else
    ## If the item is not a list, get rid of any spaces and tabs with gsub
	## ===================================================================
    str_Value="$(${cmd_AWK} 'BEGIN {
       FS=":"
       IGNORECASE='"$b_IgnoreCase"' }
       $1 ~ /^ *'"$str_Pattern"'/ {gsub (/[ \t]+/, "");
         $2=$2;
         print $2}'       "${file_Request}" )" 
  fi

  ## If a value hasnt been found or is empty, use the default if one is set
  ## ======================================================================
  [[ "${str_Value}" ]] || str_Value=${str_Default}
  [[ "${b_Upper}"   ]] && str_Value=${str_Value^^}
  [[ "${b_Lower}"   ]] && str_Value=${str_Value,,}
##         tmp=${1:1}               # Strip off leading '/' . . .
##          str_Name=${tmp%%:*}     # Extract name.
##          str_Value=${tmp##*:}         # Extract value.
##          eval $str_Name=${str_Value}

## echo "${str_Name}=\"${str_Value}\""
  eval "${str_Name}=\"${str_Value}\""
}
readonly -f GetVar

NGetVar()
{
  typeset local str_Pattern=
  typeset local str_Name=
  typeset local str_Value=
  typeset local str_Default=
  typeset local b_IgnoreCase=1
  typeset local b_List=
  typeset local b_Upper=
  typeset local b_Lower=
  
  if [ $# -ne 0 ] ; then
    while [ $# -gt 0 ] ; do
      case "${1}" in
        -pattern ) shift ; str_Pattern="${1}" ;;
        -name    ) shift ; str_Name="${1}"    ;;
        -default ) shift ; str_Default="${1}" ;;
        -c       )         b_IgnoreCase=0     ;;
        -list    )         b_List=1           ;;
        -upper   )         b_Upper=1          ;;
        -lower   )         b_Lower=1          ;;
      esac
      shift
    done
  fi

  grep -i "${str_Pattern}" ${file_Request}
  _tmp=$(grep -i "^ *${str_Pattern} *:" ${file_Request})
  echo "TMP is <${_tmp}>"
  Nstr_Name=${_tmp%%:*}
  Nstr_Value=${_tmp##*:}
  [[ "${b_Upper}"   ]] && Nstr_Value=${Nstr_Value^^}
  [[ "${b_Lower}"   ]] && Nstr_Value=${Nstr_Value,,}

  echo ${Nstr_Name}"=\"${Nstr_Value}\""
  sleep 5
}

fn_Transition()
{
  ## Transition a job to a new state
  ## ===============================

  typeset local str_Transition="${1}"
  fn_ShowTop
  printf "\n\nSelect jobs to move to $1 state\n\n"

  case ${str_Transition} in

    ## Jobs requiring the dispatcher
    queue   ) fn_ShowJobs failed fixing superseded new      ; str_Target="${dir_Queued}" ; fn_CheckDispatcher ;;
    resume  ) fn_ShowJobs failed fixing superseded          ; str_Target="${dir_Queued}" ; fn_CheckDispatcher ;;

    ## Jobs not requiring the dispatcher
    delete  ) fn_ShowJobs failed fixing superseded new      ; str_Target="${dir_Deleted}" ;;
    unqueue ) fn_ShowJobs failed superseded starting queued ; str_Target="${dir_New}"     ;;
    pause   ) fn_ShowJobs running starting queued pending   ; str_Target="${dir_Active}" ;;

  esac

  fn_ShowLine
  if [ ${#arr_Jobs[@]} != 0 ] ; then
    fn_GetAnswer range
  else
    printf "\n\tThere are no suitable jobs for that action\n\n"
    fn_GetAnswer
  fi

  arr_Answer=$(fn_Range "${str_Answer}")
  if [ "${arr_Answer}" != "x " ] ; then
    for int_Choice in ${arr_Answer} ; do
	    if [[ ${int_Choice} -le 0 ]] || [[ ${int_Choice} -ge ${int_Count} ]] ; then
        printf "Out of range" 
        fn_PressEnter
        return 0
      fi

      typeset local  file_Link="${dir_Job}"/${arr_States[${int_Choice}]}/${arr_Jobs[${int_Choice}]}
      typeset local   file_Job="${dir_Active}/${arr_Jobs[${int_Choice}]}"
      typeset local   file_Log="${dir_Log}/$(basename "${file_Job}")".log
      typeset local file_Rules="${dir_Active}/$(basename "${file_Link}")".rules

      fn_Audit "${file_Job}" "$(basename "${str_Target}")"
      case ${str_Transition} in
        queue   ) fn_CheckOwner "${file_Job}"
                  fn_UpdateResumePoint "${file_Job}" 0
                  if [ -r "${file_Rules}" ] ; then
                    mv "${file_Link}" "${dir_Pending}"/.
                    echo " Pending Parents[$(cat ${file_Rules} | grep "PARENT:" | wc -l )] " >> "${file_Log}"
                  else
                    mv "${file_Link}" "${str_Target}"/.
                  fi ;;
        unqueue ) fn_CheckOwner "${file_Job}"
                  mv "${file_Link}" "${str_Target}"/. ;;
        delete  ) fn_CheckOwner "${file_Job}"
                  echo ",,,$(date +%s),$(basename ${file_Job}),,,-1,${str_User}" >> "${file_CSV}"
                  mv "${file_Link}" "${str_Target}"/. ;;
        resume  ) fn_CheckOwner "${file_Job}"
                  fn_LogWhy
                  fn_UpdateResumePoint "${file_Job}" "$(( $(fn_GetResumePoint "${file_Log}") ))"
                  mv "${file_Link}" "${str_Target}"/.    ;;
        pause   ) fn_CheckOwner "${file_Job}"
                  if [ -f "${dir_Active}"/"$(basename "${file_Job}").pause" ] ; then
                    rm "${dir_Active}"/"$(basename "${file_Job}").pause"
                    fn_Audit "${file_Job}" "pause removed. Current task will continue"
                  else
                    touch "${dir_Active}"/"$(basename "${file_Job}").pause"
                    fn_Audit "${file_Job}" "pause set. Current task will not continue"
                  fi
                  fn_LogWhy ;;

       ## Cannot skip multiple jobs # s | S ) fn_UpdateResumePoint "${file_Job}" "$(( $(fn_GetResumePoint ${file_Log}) + 1 ))"  ;;
    
      esac
    done
  fi
}
readonly -f fn_Transition

fn_CheckOwnJobs()
{
  if [ "$(find "${dir_Starting}/." "${dir_Queued}/." "${dir_Pending}/." -name "${str_JobPrefix}*" -exec grep -l ^str_Owner="${str_Owner}" {} \; )" ] ; then
    printf "\n\n%s\n" "You have queued jobs that have not yet been started."
    read -n 1 -p "Do you want to run a version in background to complete them? [y/n] " char_Answer
    printf "\n\n"
    [[ "${char_Answer}" = "y" ]] || [[ "${char_Answer}" = "Y" ]] && nohup "${dir_Base}"/${str_ProgramName} -background -j ${dir_Job} </dev/null >> "${file_ProgLog}" &
  fi
}
readonly -f fn_CheckOwnJobs

fn_SetJobOwner()
{
  typeset local file_Job="${1}"
  if grep "^str_Owner=" "${file_Job}" ; then
    fn_Audit "${file_Job}" "accepted ownership of the job"
    sed 's/^str_Owner=.*/str_Owner='${str_User}'/g' "${file_Job}" > "${file_Job}".tmp
	mv "${file_Job}".tmp "${file_Job}"
  fi
}
readonly -f fn_SetJobOwner

fn_CheckOwner()
{
  typeset local file_Job="${1}"
  if ! grep "^str_Owner=${str_User}" "${file_Job}" ; then
    printf "\n\nYou do not own this job\n\nCurrent owner: $(grep "^str_Owner=" "${file_Job}")\n\n"
    read -n 1 -p "Do you wish to take ownership? [y/n]: "
    case $REPLY in
      y | Y ) fn_SetJobOwner "${file_Job}" ;;
	  * ) break ;;
    esac
  fi
}
readonly -f fn_CheckOwner
