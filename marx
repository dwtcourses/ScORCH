#!/bin/bash
#-------------------------------------------------------------------------------
#
#                            ORCHESTRATION FRAMEWORK
#
#-------------------------------------------------------------------------------
#
# COMPONENT     bin/dman
#
# USAGE         dman  <options> <arguments>...
#
# DESCRIPTION   Deployment Manager -
#
# EXAMPLES      dman
#
#-------------------------------------------------------------------------------
#
# REVISION HISTORY
#
# Date       Author            JIRA      Summary
# ----       ------            ----      -------
# 20140515   Marc Loftus       n/a       Created
#
# 20140918   Marc Loftus       n/a       V1.0 First Release (No Queue Manager)
# 20140923   loftusm396        n/a       Added housekeeping
# 20141016   loftusm396        n/a       Queue Manager and enhancements
# 20141024   loftusm396        n/a       Deployment decoupling
# 20141104  loftusm396          1.3       Relative paths reviewed (No 4 of PDB-232)
# 20141104  loftusm396          1.4       Allow daemon to die if no queued jobs (No 7 of PDM-232)
#                                         Fixed exit issue when using DoWhat function
#                                         Identify job owner on screen and stubbed change within job
#                                         Allow dman to start without the daemon  using -man option
#                                         Only the owner of a job can start the job
#                                         The daemon can start self service jobs (depagent)
#                                         Users can enter message of the day (motd)
#                                         Failure log capture to job
#                                         Leaving function message has been left justified
#                                         Template captured to bottom of jobfile
#                                         Default template action_list made blank for easy exit
#                                         Added example template for SAFEDEMO hostname plugin
# 20141106  loftusm396          1.5       Stubbing authorised users
#                                         Allows dman -file <file_request>
# 20141107  loftusm396          1.6       Clear-up of variables that are not used
#                                         Silent Plugins if self service FILE used
#                                         ALLOW_START of self service jobs using -s flag
#                                         Unqueue now allows unqueue of jobs in STARTING state.
#                                         JOB_NUM_ID expanded to include job count
#                                         Completed jobs deleted if there are too many
#                                         Improved orphan lock checking
#                                         Improved dead-running job checking
#                                         Improved dispatch log details
# 20141111  loftusm396          1.7       FIP Notification
#                                         Out of range handling
#                                         Improved resume logic
# 20141112  loftusm396          1.8       Fixed LOCK_PID of dispatcher to account for underscores in username
#                                         ALLOW_START and FILE fully initialised included an = sign
# 20141113  loftusm396          1.9       Add task start/finish to the log file
#                                         Additional failure logging from DoWhat function
#                                         Ability to skip a failed task in a job
# 20141114  loftusm396          1.10      Added alternative plugin dir options
#                                                 export PLUGINDIR=/<my pluging dir> before starting dman or
#                                                 dman -p <my plugin dir>
# 20141117  loftusm396          1.11      Permissions problems handled between jobs and log files
#                                         Job ownership added when starting a job you dont own
#                               1.11a     Auditing PID added to AddTask
# 20141119  loftusm396          1.12      Auto started file jobs will now run as depagent
#-------------------------------------------------------------------------------

typeset VERSION=1.12

set -u

# Source the common envs file
# ===========================
#typeset COMMON_WPENVS=/deployment/space/common/etc/wpenvs
#. ${COMMON_WPENVS}
#typeset ORCHESTRATION_WPENVS=/deployment/etc/wpenvs
#. ${ORCHESTRATION_WPENVS}
#########################
# PRIVATE KEYS
DEPHOME=~deploy
KEYDIR=${DEPHOME}/deployment/keys
OPENKEY="-i ${KEYDIR}/OPENKEY"
#########################



# DEBUG LIBRARY FUNCTIONS SETTINGS
# ================================
typeset PROGNAME=$(basename ${BASH_SOURCE})
typeset RUNDIR=$(dirname ${BASH_SOURCE})

# Figure out the path to the programe based on the dirname
if [[ $(echo "${RUNDIR}" | grep "^ *\.") ]] ; then
  # Reletive path
  typeset BASEDIR=$(cd $(pwd)/$(dirname  ${BASH_SOURCE})/.. ; pwd)
else
  # Absolute path
  typeset BASEDIR=$(cd $(dirname  ${BASH_SOURCE})/.. ; pwd )
fi

typeset ETCDIR=${BASEDIR}/etc
typeset MOTD_FILE=${ETCDIR}/motd
typeset LOGDIR=$BASEDIR/var/log/
typeset PLUGINDIR=${PLUGINDIR:-${BASEDIR}/plugins}
typeset LOG_FILE=${LOGDIR}/${PROGNAME}.log

# Common envs include DEPHOME BINDIR ETCDIR VARDIR LOGDIR SPACEDIR FUNCDIR TMPDIR JOBIDFILE RELMGR_<envs>


# Global variables that require setup before the script runs correctly
# ====================================================================
typeset LOGGING=file # Log level: file | none | interactive (Used with WPMessage)
typeset DEBUG=off    # Debug Level: on | off | full (Used with WPCheckRC)
typeset DATEFORMAT="+%y%m%d-%H%M%S"
typeset START_TIME="$(date +%s)"
typeset NONINTERACTIVE=""
typeset DEPLOYMENTTEAM="dldeploymentteam@domain.com"
typeset MAINTENANCE_FILE="${BASEDIR}/etc/maintenance"
typeset JOBIDFILE=${BASEDIR}/var/jobnum
typeset WARNINGCOUNT=0
typeset WHOAMI=$(whoami)


# Authorised Users Stubbing
# =========================
# For future enhancements based on project type or plugin sub-dir i.e PSC. Or just for viewing
typeset RESTRICTED=TRUE
typeset ACCESS_LEVEL=none

# JOB HANDLING VARS
# =================
typeset JOBDIR=${BASEDIR}/jobs
typeset NEW_JOBDIR=${JOBDIR}/new
typeset DELETED_JOBDIR=${JOBDIR}/deleted
typeset FAILED_JOBDIR=${JOBDIR}/failed
typeset RUNNING_JOBDIR=${JOBDIR}/running
typeset STARTING_JOBDIR=${JOBDIR}/starting
typeset QUEUED_JOBDIR=${JOBDIR}/queued
typeset ARCHIVED_JOBDIR=${JOBDIR}/archived
typeset COMPLETED_JOBDIR=${JOBDIR}/completed
typeset SUPERSEDED_JOBDIR=${JOBDIR}/superseded
typeset LOG_JOBDIR=${BASEDIR}/var/tmp
typeset TMPDIR=${BASEDIR}/var/tmp
# stubbed for future enhancement typeset HEADERFILE=${BASEDIR}/etc/JobHeader
# stubbed for future enhancement typeset FOOTERFILE=${BASEDIR}/etc/JobFooter
typeset TASKNUMBER=0
typeset OWNER=""
typeset SELF_SERVICE_USER="depagent"
typeset ALLOW_START=


# PLUGIN DEFAULTS
# ===============
typeset JIRADIR="http://jira.domain.local/browse/"
typeset JIRA_TEST_ID="DEP-TST"
typeset JIRAID="DEP-TST"
typeset WPDEPLOY="wpdeploy"
typeset ENVIRONMENT="DEV00"
typeset RELEASE="NONE"
typeset ACTION="ACTION"
typeset FILE=


# LAYOUT VARS used in ShowJobs and ShowTop
# =======================================
typeset TOP_DISPLAY_WIDTH=120
typeset SCREEN_WIDTH=$(tput cols)
typeset NO_WDTH=3
typeset DEP_WDTH=10
typeset JIRA_WDTH=10
typeset ID_WDTH=6
typeset ENV_WDTH=8
typeset ACT_WDTH=15
typeset VER_WDTH=10


# DISPATCHER VARS
# ===============
typeset DAEMON=
typeset LOCK_PID=0
typeset LOCKDIR=${BASEDIR}/var/locks
typeset LOCK_FILE=${LOCKDIR}/lock
typeset LINK_DETAILS=${WHOAMI}
typeset DISPATCH_LOCK=${LOCKDIR}/dispatch.lock
typeset DISPATCH_LOG=${TMPDIR}/dispatch.log
typeset PID=$$


# LOG VARS
# ========
typeset LOG_LIST="\$(date ${DATEFORMAT}),\${START_TIME},\${FINISH_TIME},\${JOB_NAME}"
typeset CSV_FILE=${LOG_JOBDIR}/alljobs.csv


# HOUSE KEEPING variables - number of days before house keeping is performed on the directory
# ===========================================================================================
typeset HOUSEKEEP_COMPLETED=10
typeset HOUSEKEEP_COMPLETED_MAX=30
typeset HOUSEKEEP_DELETED=20


Help()
{

  # Help should always be available in any script
  # =============================================

  Usage
  echo " "
  echo "${PROGNAME} [-l] | FUNCTION_TAG [options]"
  echo "    -h     Help"
  echo "    -l     Lists the available tags"
  echo "    -v     Version"
  echo "    -p     <alternative plugin dir>"
  echo "    -file  <file template> [-s]"
  echo "           -s     Means that jobs added with -file can start now"
  echo " "
  echo "    Examples:"
  echo " "

}

Usage()
{
  echo "${PROGNAME} [options] | -h | -v "
}

# ARGUMENTS LIST FIRST CHECK ARGUMENTS TO THE FRAMEWORK
# =====================================================
if [ $# -ne 0 ] ; then
  while [ $# -gt 0 ] ; do
    _ARG="$1"
    case ${_ARG} in
      -h ) Help ; exit 0;;
      -daemon ) DAEMON=1           ;;
      -man  ) DAEMON=0             ;;
      -d    ) DEBUG=full ; set +u  ;;
      -n    ) NONINTERACTIVE=1     ;;
      -p    ) shift ; PLUGINDIR=$1 ;;
      -file ) shift ; FILE=$1      ;;
      -s    ) ALLOW_START=TRUE     ;;
      -v    ) echo "VERSION[$PROGNAME] $VERSION" ; exit 0 ;;
    esac
    shift
  done
fi



HouseKeeping()
{
  # The function will be run after the script finishes.
  WPMessage "House Keeping..."

  #If there are more than 30 completed jobs, use the time stamps to move the rest to the archived dir
  [ $(ls $COMPLETED_JOBDIR/* 2> /dev/null | wc -l ) -ge ${HOUSEKEEP_COMPLETED_MAX} ] && find ${COMPLETED_JOBDIR}/* ! -newer ${COMPLETED_JOBDIR}/$(ls -1t ${COMPLETED_JOBDIR} | head -${HOUSEKEEP_COMPLETED_MAX} | tail -1) -exec mv -f {} ${DELETED_JOBDIR}/. \; > /dev/null 2>&1

  # Search the COMPLETED_JOBDIR and archive jobs older than 10 days
  find ${COMPLETED_JOBDIR}/*_* -mtime +${HOUSEKEEP_COMPLETED} -exec mv {} ${DELETED_JOBDIR} \; 2>/dev/null

  # Search the DELETED_JOBDIR and tar append them to an archive file then rm jobs older than 20 days
  find ${DELETED_JOBDIR}/*_* -mtime +${HOUSEKEEP_DELETED} -exec tar uf ${DELETED_JOBDIR}/archive.tar "{}" + 2>/dev/null && find ${DELETED_JOBDIR}/*_* -mtime +${HOUSEKEEP_DELETED} -exec rm -f {} \; 2>/dev/null
}


CheckSetUp()
{
  MODULE=$(push "$MODULE" "${FUNCNAME}")
  SCENE="Entering ${FUNCNAME}"
  WPCheckRC 0 "Entering ${FUNCNAME}"

  typeset CHECKS=0
  # printf "Checking Setup\n\n"

  # Check the list of directories that should exist with deployment team access
  # ===========================================================================
  typeset local DIRLIST="NEW_JOBDIR FAILED_JOBDIR RUNNING_JOBDIR STARTING_JOBDIR DELETED_JOBDIR COMPLETED_JOBDIR QUEUED_JOBDIR SUPERSEDED_JOBDIR ARCHIVED_JOBDIR TMPDIR LOCKDIR LOGDIR ETCDIR PLUGINDIR"
  for _EACH_DIR in ${DIRLIST} ; do
    #echo chechking ${_EACH_DIR}
    #echo ${!_EACH_DIR}
    [[ ! -d ${!_EACH_DIR} ]] && echo mkdir -p -m 770 ${!_EACH_DIR} && CHECKS=1
  done

  # Check files that need to exist
  # ==============================
#  typeset local FILELIST="$JOBNUM"

  if [[ ${CHECKS} -ne 0 ]] ; then
    printf "\n\n Please create the above directories to complete setup.\n"
    exit 1
  fi

  WPCheckRC 0 "Leaving ${FUNCNAME}"
  MODULE=$(cdr "$MODULE")
}

CheckAuthorisation()
{
  # Currently stubbed for future enhancements

  MODULE=$(push "$MODULE" "${FUNCNAME}")
  SCENE="Entering ${FUNCNAME}"
  WPCheckRC 0 "Entering ${FUNCNAME}"

  # Check what areas the user has access to
  echo ${WHOAMI}
  if [ -r ${ETCDIR}/users ] ; then
    echo "Checking authority"
    ACCESS_LEVEL=$(grep ${WHOAMI} ${ETCDIR}/users | cut -d: -f2)
    [[ $(echo ${ACCESS_LEVEL} | grep FULL) ]] && RESTRICTED=""

    if [[ ! "${ACCESS_LEVEL}" ]]  ; then
      echo "User ${WHOAMI} not authorised"
      exit 1
    else
      # Develop further
      echo restricted role grep
    fi
  else
    echo "There is no valid or readable users files: ${ETCDIR}/users."
    echo "  Add a list of users to the file"
    exit 1
  fi

  WPCheckRC 0 " Leaving ${FUNCNAME}"
  MODULE=$(cdr "$MODULE")
}


InitPlugins()
{
  MODULE=$(push "$MODULE" "${FUNCNAME}")
  SCENE="Entering ${FUNCNAME}"
  WPCheckRC 0 "Entering ${FUNCNAME}"

  # Show the available plugins (should be true functions not scripts)
  if [[ ! ${FILE} ]]  ; then
    clear
    ShowTop
    ShowLine "-" Plugins
  fi
  PLUGINS=$(find -L ${PLUGINDIR} -name "Plugin_*" | sort)

  for _EACH_PLUGIN in ${PLUGINS} ; do
    [[ ${FILE} ]] || printf "%-30s" "$(basename ${_EACH_PLUGIN} | cut -d_ -f2-)"

    # Need to check for true plugin functions or scripts
    _STATUS="${greenf}OK${reset}"
    if grep "^ *$(basename ${_EACH_PLUGIN})()" ${_EACH_PLUGIN} > /dev/null  ; then
       bash ${_EACH_PLUGIN} > /dev/null 2>&1 && . ${_EACH_PLUGIN} || _STATUS="${redb}Corrupted${reset}"
       [[ ${FILE} ]] || printf "%s\n" "${_STATUS} plugin"
    else
      [[ ${FILE} ]] || printf "%s\n" "script"
    fi

  done
  #sleep 2

  WPCheckRC 0 "Leaving ${FUNCNAME}"
  MODULE=$(cdr "$MODULE")
}

ShowLine()
{
  MODULE=$(push "$MODULE" "${FUNCNAME}")
  SCENE="Entering ${FUNCNAME}"
  WPCheckRC 0 "Entering ${FUNCNAME}"

  # Simple function to display a full screen of characters as a seperator
  # The first Variable passed is the symbol(s) that will make up the line (equal sign "=" being the default)
  # The second Variable passed can be used to TITLE the line.
  # eg ShowLine x Hello
  #     xxxHelloxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
  typeset local SCREEN_WIDTH=$(tput cols)
  typeset local _TEXT=${1:-"="}
  typeset local _TITLE=${2:-""}
  typeset local _TEXT_WIDTH=$(echo ${_TEXT} | wc -c)
  (( _TEXT_WIDTH=${_TEXT_WIDTH} -1 ))
  typeset local _TITLE_WIDTH=$(echo $_TITLE | wc -c)
  (( _TITLE_WIDTH=${_TITLE_WIDTH} -1 ))
  (( _DISPLAY_WIDTH=(${SCREEN_WIDTH}-(${_TEXT_WIDTH}*3)-${_TITLE_WIDTH} )/${_TEXT_WIDTH} ))
  # There is an extra space due to "-" minus being interpretted as an argument to printf
  printf " ${_TEXT}${_TEXT}${_TITLE}%${_DISPLAY_WIDTH}s\n" | sed "s/ /${_TEXT}/g"

  WPCheckRC 0 "Leaving ${FUNCNAME}"
  MODULE=$(cdr "$MODULE")
}

ShowJobs()
{
  MODULE=$(push "$MODULE" "${FUNCNAME}")
  SCENE="Entering ${FUNCNAME}"
  WPCheckRC 0 "Entering ${FUNCNAME}"

  # This function takes a list of directory names as a parameter and displays the jobs
  # in each of those directories. The jobs location is the jobs STATE. The job itself is
  # responsible for changing STATE once running to completed or failed
  #
  for _EACH_STATE in $@ ; do
    typeset local _DIRECTORY=${_EACH_STATE}
    typeset local _L_DIRECTORY=$(echo ${_DIRECTORY} | tr [:upper:] [:lower:])
    typeset local _U_DIRECTORY=$(echo ${_DIRECTORY} | tr [:lower:] [:upper:])
    JOB_ARRAY=""


    # Get a list or jobs in the passed directory (For completed jobs put that order in time order so most recently completed jobs show first)
    [[ ${_U_DIRECTORY} = "COMPLETED" ]] && _JOBS=$(ls -1t ${JOBDIR}/${_L_DIRECTORY}) || _JOBS=$(ls -1rt ${JOBDIR}/${_L_DIRECTORY})

    # If there are any _JOBS in the directory display each of the jobs
    if [ "${_JOBS}" ] ; then

      #[[ ${_U_DIRECTORY} = "FAILED" ]] && ShowLine - ${redb}${_U_DIRECTORY}${reset} || ShowLine - ${_U_DIRECTORY}
      ShowLine - ${_U_DIRECTORY}
      typeset local SCREEN_WIDTH=$(tput cols)
      for _EACH_JOB in ${_JOBS} ; do
        [[ ${_U_DIRECTORY} = "FAILED" ]] && RED="${redb}"  || RED="${reset}"
        [[ ${_U_DIRECTORY} = "FAILED" ]] && [ "$(tail -1 ${TMPDIR}/${_EACH_JOB}.log | grep -w FIP)" != "" ] && RED="${reset}"


        # Highlight jobs that we are the current owner of
        if [[ -r  ${JOBDIR}/${_L_DIRECTORY}/${_EACH_JOB} ]] ; then
           [[ "$(grep "OWNER=" ${JOBDIR}/${_L_DIRECTORY}/${_EACH_JOB} | tail -1 | cut -d= -f2 2>/dev/null )" == "${WHOAMI}" ]] && OWNER="*" || OWNER=" "
        else
           # or show a "!" if there is a read error
           OWNER="!"
        fi

        #     linenum owner | Jiraid | jobnum | env | plugin | release
        #printf "%s %${NO_WDTH}s%1s %${DEP_WDTH}s %${JIRA_WDTH}s %${ENV_WDTH}s %${ACT_WDTH}s %${VER_WDTH}s %s" \
        printf "%s %${NO_WDTH}s%1s %${JIRA_WDTH}s %${ID_WDTH}s %${ENV_WDTH}s %${ACT_WDTH}s %${VER_WDTH}s %s" \
               "${RED}" "${COUNT}" "${OWNER}" $(echo ${_EACH_JOB} | sed 's/_/\| /g')  "| "
        (( _DISPLAY_WIDTH=$SCREEN_WIDTH - ${NO_WDTH} - ${JIRA_WDTH} - ${ID_WDTH} - ${ENV_WDTH} - ${ACT_WDTH} - ${VER_WDTH} - 13 ))
        if [[ ${_DISPLAY_WIDTH} -lt 1 ]]  ; then
          echo "Screen to small${reset}"
        else
          [[ -r ${LOG_JOBDIR}/${_EACH_JOB}.log ]] && printf "%s\n" "$(tail -10 ${LOG_JOBDIR}/${_EACH_JOB}.log  | grep -v "] .*----------------" | tail -1 | cut -c1-${_DISPLAY_WIDTH})${reset}" || echo "Check permissions"
        fi

        # Load the JOB Array and JOB Location
        JOB_ARRAY[${COUNT}]=${_EACH_JOB}
        JOB_STATE[${COUNT}]=${_L_DIRECTORY}
        JOB_OWNER[${COUNT}]="TRUE"

        (( COUNT+=1 ))
      done
    fi
  done

  WPCheckRC 0 "Leaving ${FUNCNAME}"
  MODULE=$(cdr "$MODULE")
}

ShowOwnJobs()
{
  MODULE=$(push "$MODULE" "${FUNCNAME}")
  SCENE="Entering ${FUNCNAME}"
  WPCheckRC 0 "Entering ${FUNCNAME}"

  # This function takes a list of directory names as a parameter and displays the jobs
  # in each of those directories. The jobs location is the jobs STATE. The job itself is
  # responsible for changing STATE once running to completed or failed
  #
  for _EACH_STATE in $@ ; do
    typeset local _DIRECTORY=${_EACH_STATE}
    typeset local _L_DIRECTORY=$(echo ${_DIRECTORY} | tr [:upper:] [:lower:])
    typeset local _U_DIRECTORY=$(echo ${_DIRECTORY} | tr [:lower:] [:upper:])
    JOB_ARRAY=""


    # Get a list or jobs in the passed directory (For completed jobs put that order in time order so most recently completed jobs show first)
    _JOBS=$(grep -wl "OWNER=${WHOAMI}" ${JOBDIR}/${_L_DIRECTORY}/* 2>/dev/null)

    # If there are any _JOBS in the directory display each of the jobs
    if [ "${_JOBS}" ] ; then

      #[[ ${_U_DIRECTORY} = "FAILED" ]] && ShowLine - ${redb}${_U_DIRECTORY}${reset} || ShowLine - ${_U_DIRECTORY}
      ShowLine - ${_U_DIRECTORY}
      typeset local SCREEN_WIDTH=$(tput cols)
      for _EACH_JOB in ${_JOBS} ; do
        _EACH_JOB=$(basename ${_EACH_JOB})
        [[ ${_U_DIRECTORY} = "FAILED" ]] && RED="${redb}"  || RED="${reset}"
        [[ ${_U_DIRECTORY} = "FAILED" ]] && [ "$(tail -1 ${TMPDIR}/${_EACH_JOB}.log | grep -w FIP)" != "" ] && RED="${reset}"


        # Highlight jobs that we are the current owner of
        if [[ -r  ${JOBDIR}/${_L_DIRECTORY}/${_EACH_JOB} ]] ; then
           [[ "$(grep "OWNER=" ${JOBDIR}/${_L_DIRECTORY}/${_EACH_JOB} | tail -1 | cut -d= -f2 2>/dev/null )" == "${WHOAMI}" ]] && OWNER="*" || OWNER=" "
        else
           # or show a "#" if there is an error
           OWNER="#"
        fi

        #     linenum owner | Jiraid | jobnum | env | plugin | release
        #printf "%s %${NO_WDTH}s%1s %${DEP_WDTH}s %${JIRA_WDTH}s %${ENV_WDTH}s %${ACT_WDTH}s %${VER_WDTH}s %s" \
        printf "%s %${NO_WDTH}s%1s %${JIRA_WDTH}s %${ID_WDTH}s %${ENV_WDTH}s %${ACT_WDTH}s %${VER_WDTH}s %s" \
               "${RED}" "${COUNT}" "${OWNER}" $(echo ${_EACH_JOB} | sed 's/_/\| /g')  "| "
        (( _DISPLAY_WIDTH=$SCREEN_WIDTH - ${NO_WDTH} - ${JIRA_WDTH} - ${ID_WDTH} - ${ENV_WDTH} - ${ACT_WDTH} - ${VER_WDTH} - 13 ))
        if [[ ${_DISPLAY_WIDTH} -lt 1 ]]  ; then
          echo "Screen to small${reset}"
        else
          [[ -r ${LOG_JOBDIR}/${_EACH_JOB}.log ]] && printf "%s\n" "$(tail -10 ${LOG_JOBDIR}/${_EACH_JOB}.log  | grep -v "] .*----------------" | tail -1 | cut -c1-${_DISPLAY_WIDTH})${reset}" || echo "Check permissions"
        fi

        # Load the JOB Array and JOB Location
        JOB_ARRAY[${COUNT}]=${_EACH_JOB}
        JOB_STATE[${COUNT}]=${_L_DIRECTORY}
        JOB_OWNER[${COUNT}]="TRUE"

        (( COUNT+=1 ))
      done
    fi
  done

  WPCheckRC 0 "Leaving ${FUNCNAME}"
  MODULE=$(cdr "$MODULE")
}



ShowOptions()
{
  MODULE=$(push "$MODULE" "${FUNCNAME}")
  SCENE="Entering ${FUNCNAME}"
  WPCheckRC 0 "Entering ${FUNCNAME}"

  # This function creates context based menu option.
  # It may be used in several places so has been seperated from the Manager function
  # Is looks through the job STATES and displays actions that can be run against those STATES
  # If a STATE variable is passed then only show valid values for that variable
  typeset local LOCAL=${1:-}

  QUEUED=
  FAILED=
  NEW=
  RUNNING=
  DELETE=

  if [[ "$LOCAL" ]]  ; then
    printf "\n (E)dit Job |"
    case $LOCAL in
      qu* ) QUEUED=1  ;;
      fa* ) FAILED=1  ;;
      ne* ) NEW=1     ;;
      ru* ) RUNNING=1 ;;
    esac
  else
    printf "\n (A)dd |"

    # If there are QUEUED jobs, they may be UNQUEUED to a NEW state or IMPORTANCE increased to run NEXT
    [[ "$(ls ${QUEUED_JOBDIR}/* 2>/dev/null)" ]] && QUEUED=1

    # If there are RUNNING jobs, they may be PAUSED to a NEW state
    [[ "$(ls ${RUNNING_JOBDIR}/*  2>/dev/null)" ]] && RUNNING=1

    # If there are NEW or FAILED, they may be STARTED to QUEUED or DELETED
    [[ "$(ls ${NEW_JOBDIR}/* 2>/dev/null)" ]] && NEW=1 && DELETE=1

    # If there is a FAILED job it may be (R)esumed
    [[ "$(ls ${FAILED_JOBDIR}/* 2>/dev/null)" ]] && NEW=1 && FAILED=1 && DELETE=1

  fi

  # Show available options depending on the STATE of jobs
  [ $QUEUED ] && printf " (U)nqueue | (C)hange order |"
  [ $RUNNING ] && printf " (P)ause |"
  ( [ $NEW  ] || [[ $FAILED ]] ) && printf " (S)tart |"
  [ $FAILED ] && printf " (R)esume | (F)ixing | s(K)ip |"
  [ $DELETE ] && printf " (D)elete |"

  printf " (L)og | (T)asks |"
  if [[ ! "${LOCAL}" ]] ; then
    printf " (M)otd |"
  fi
  printf " e(X)it"
  printf "\n\n Enter option: "

  WPCheckRC 0 "Leaving ${FUNCNAME}"
  MODULE=$(cdr "$MODULE")
}


RunOwnJobs()
{
  MODULE=$(push "$MODULE" "${FUNCNAME}")
  SCENE="Entering ${FUNCNAME}"
  WPCheckRC 0 "Entering ${FUNCNAME}"

  typeset local _STARTJOBS=$(grep OWNER=${WHOAMI} ${STARTING_JOBDIR}/* 2>/dev/null )
  echo "Checking own jobs....."
  echo ${_STARTJOBS}

  WPCheckRC 0 "Leaving ${FUNCNAME}"
  MODULE=$(cdr "$MODULE")
}

Ck_Dispatcher()
{
  MODULE=$(push "$MODULE" "${FUNCNAME}")
  SCENE="Entering ${FUNCNAME}"
  WPCheckRC 0 "Entering ${FUNCNAME}"

  # Function to monitor and start the dispatcher


  # Check the existance of a current dispatch file
  # Do this with the -L symbolic link test
  if [ -L ${DISPATCH_LOCK} ] ; then
    LOCK_PID=$(ls -l ${DISPATCH_LOCK} | cut -d">" -f2- |  awk -F"_" '{print $NF}' )

    # Check the process list to make sure an application is running for the dispatcher
    if [[ ! $(ps -p ${LOCK_PID} | grep ${PROGNAME}) ]] ; then
      WPMessage "Previous daemon died. Removing lock file ${DISPATCH_LOCK}"
      rm  ${DISPATCH_LOCK}
    fi

  else
    #WPMessage "Checking if already running"
    if [ "$( ps -ef | grep ${PROGNAME} | grep daemon)" ] ; then
      # If there's a previous daemon running - reset the lock file
      WPMessage "Repairing lock file ${LINK_DETAILS} ${DISPATCH_LOCK}"
      LINK_DETAILS=${WHOAMI}_${PROGNAME}_$( ps -ef | grep ${PROGNAME} | grep daemon | tail -1 | awk -F" " '{print $2}')
      ln -s  ${LINK_DETAILS} ${DISPATCH_LOCK}
    else
      #WPMessage "Initialting dispatcher"
      ${RUNDIR}/${PROGNAME} -daemon >> ${DISPATCH_LOG} 2>&1 &
    fi
  fi

  WPCheckRC 0 "Leaving ${FUNCNAME}"
  MODULE=$(cdr "$MODULE")
}

Dispatcher_Daemon()
{
  # This function promotes QUEUED jobs to a STARTING state if the queue is open and
  # starts any JOBS that are owned by the self service user (depagent).
  #
  # There is some logic in place to only allow one running version of the deamon to
  # be running at any one time as well as checking to make sure the deamon lock file
  # is in place and correct
  MODULE=$(push "$MODULE" "${FUNCNAME}")
  SCENE="Entering ${FUNCNAME}"
  WPCheckRC 0 "Entering ${FUNCNAME}"

  typeset local LINK_DETAILS=${WHOAMI}_${PROGNAME}_${PID}
  typeset local QUEUE_CHECK_COUNT=1
  typeset local QUEUE_CHECK_MAX=20

  CURRENT_PID="$( ps -ef | grep -v ${PID} | grep ${PROGNAME} | grep daemon)"

  # Check for several different scenarios of running daemon and PID lock file
  [[   -L ${DISPATCH_LOCK} ]] && [[ ${CURRENT_PID} = "" ]]  && WPMessage "Dispatcher: Remove previous lock" && rm -f ${DISPATCH_LOCK} > /dev/null 2>&1
  [[ ! -L ${DISPATCH_LOCK} ]] && [[ ${CURRENT_PID} = "" ]]  && WPMessage "Dispatcher: Set lock file : ${LINK_DETAILS}" && ln -s  ${LINK_DETAILS} ${DISPATCH_LOCK}
  [[   -L ${DISPATCH_LOCK} ]] && [[ ${CURRENT_PID} != "" ]] && WPMessage "Dispatcher: Already running : ${LINK_DETAILS}" && exit 1
  [[ ! -L ${DISPATCH_LOCK} ]] && [[ ${CURRENT_PID} != "" ]] && WPMessage "Dispatcher: Repairing lock file : ${LINK_DETAILS}" && \
                        LINK_DETAILS=${WHOAMI}_${PROGNAME}_$( ps -ef | grep ${PROGNAME} | grep daemon | tail -1 | awk -F" " '{print $2}') &&  \
                        ln -s  ${LINK_DETAILS} ${DISPATCH_LOCK} && exit 1


  # Check for a set number of loops (default 20)
  while [ ${QUEUE_CHECK_COUNT} -le ${QUEUE_CHECK_MAX} ]  ; do


    # Exit if the maintenance file has been set
    if [[ -f ${MAINTENANCE_FILE}  ]] ; then
      echo "${PROGNAME} is down for maintenance."
      echo "To reset ${PROGNAME} : rm ${MAINTENANCE_FILE}"
      rm -f ${DISPATCH_LOCK} > /dev/null 2>&1
      exit 1
    fi

    typeset local _EACH_JOB

    # Function block to promote queued jobs
    typeset local QUEUED_JOBS=$(ls -rt1 ${QUEUED_JOBDIR})
    for _EACH_JOB in ${QUEUED_JOBS} ; do

      # The env lock is part 3 and part 4 of the job name i.e JIRA_IDNUM_CORE1_PSC-DEPLOY is CORE1.PSC
      _ENVLOCK=$(echo ${_EACH_JOB} | cut -d"_" -f4,3 | cut -d"-" -f1)
      #echo "envlock : ${_ENVLOCK}"

      # Check to see if a lock file for the ENV
      if [ -L ${LOCK_FILE}.${_ENVLOCK} ] ; then

          # Check if there is a valid running job (or job about to start) linked from the lock file
          typeset local _LOCKED_JOB=$(ls -l ${LOCK_FILE}.${_ENVLOCK} | awk -F" " '{print $NF}')
          if [ "$(ls ${RUNNING_JOBDIR}/${_LOCKED_JOB} 2>/dev/null)" ] || [ "$(ls ${STARTING_JOBDIR}/${_LOCKED_JOB} 2>/dev/null)" ]  ; then
                # || [[ $(ls ${STARTING_JOBDIR}/${_LOCKED_JOB} 2>/dev/null) ]]; then
            :
            # echo running job ok
          else
            WPWarning "Clearing lock file as no running job: ${_ENVLOCK}"
            rm ${LOCK_FILE}.${_ENVLOCK}
          fi

      else
        WPMessage "${_EACH_JOB} -> STARTING"
        mv ${QUEUED_JOBDIR}/${_EACH_JOB} ${STARTING_JOBDIR}/. && ln -s ${_EACH_JOB} ${LOCK_FILE}.${_ENVLOCK}
        sleep 1
      fi

      # Stubbed for dead-lock checking or jobs stuck in start state holding up the queue


      # Reset the queue check count as we have had a recent queued job
      QUEUE_CHECK_COUNT=1

    done
    #
    # Stubbed for dead-job running - so move to failed
    typeset local RUNNING_JOBS=$(ls -rt1 ${RUNNING_JOBDIR})
    for _EACH_JOB in ${RUNNING_JOBS} ; do
      if [ ! "$(ps -ef | grep ${_EACH_JOB} | grep -v grep )" ] ; then
        # Job is in a running state but cant find the job available on the system"
        echo "Job ${_EACH_JOB} without a process. Moving to failed state: Resume point:999" >> ${TMPDIR}/${_EACH_JOB}.log
        WPWarning "${_EACH_JOB} without a process -> FAILED"
        mv ${RUNNING_JOBDIR}/${_EACH_JOB} ${FAILED_JOBDIR}
      fi
    done

    StartJobs ${SELF_SERVICE_USER}

    sleep 30

    (( QUEUE_CHECK_COUNT+=1 ))

  done
  WPMessage "No queued jobs. Dispatcher exiting"
  rm -f ${DISPATCH_LOCK}

  WPCheckRC 0 "Leaving ${FUNCNAME}"
  MODULE=$(cdr "$MODULE")
}

StartJobs()
{
  MODULE=$(push "$MODULE" "${FUNCNAME}")
  SCENE="Entering ${FUNCNAME}"
  WPCheckRC 0 "Entering ${FUNCNAME}"

  typeset local USER=$1

  # Function to monitor the start directory and start jobs for USER owned jobs
  typeset local STARTING_JOBS=$(grep -l "OWNER=${USER}" ${STARTING_JOBDIR}/* 2>/dev/null )

  for _EACH_JOB in ${STARTING_JOBS} ; do
    WPMessage "Job started: $(basename ${_EACH_JOB})"
    nohup ${_EACH_JOB} < /dev/null  >> ${LOG_JOBDIR}/$(basename ${_EACH_JOB}).log &
    sleep 1
  done

  WPCheckRC 0 "Leaving ${FUNCNAME}"
  MODULE=$(cdr "$MODULE")
}

ShowTop()
{
  MODULE=$(push "$MODULE" "${FUNCNAME}")
  SCENE="Entering ${FUNCNAME}"
  WPCheckRC 0 "Entering ${FUNCNAME}"

   # This function refreshes the display Displays the top of the screen
   clear
   typeset local TITLE_WDTH
   typeset local DF_WDTH
   SCREEN_WIDTH=$(tput cols)
   (( TITLE_WDTH=${NO_WDTH} + ${JIRA_WDTH} + 3 ))
   (( TOP_DISPLAY_WIDTH=$SCREEN_WIDTH - ${TITLE_WDTH} - ${JIRA_WDTH} - ${ENV_WDTH} - 5 ))
   _DF="$(df ${BASEDIR} | tail -1 | cut -d% -f1 | awk -F" " '{print $NF}')"
   [[ ${_DF} -gt 80 ]] && _DF="${redb}${_DF}${reset}" || ( [[ ${_DF} -gt 70 ]] && _DF="${yellowb}${blackf}${_DF}${reset}" )
   printf "%${TITLE_WDTH}s %${ID_WDTH}s %${ENV_WDTH}s %${TOP_DISPLAY_WIDTH}s" "${PROGNAME}[${VERSION}]|" "${_DF}%|" "D:${LOCK_PID}|" "$(date +'%D %T')"
   echo "${reset}"
   COUNT=1

  unset JOB_STATE JOB_ARRAY
  WPCheckRC 0 "Leaving ${FUNCNAME}"
  MODULE=$(cdr "$MODULE")
}

ShowLog()
{
  MODULE=$(push "$MODULE" "${FUNCNAME}")
  SCENE="Entering ${FUNCNAME}"
  WPCheckRC 0 "Entering ${FUNCNAME}"

  #typeset local LOGDIR=${BASEDIR}/../var/log/
  typeset local _FILES=$(find $LOGDIR -name "*.log" -ctime -4)
  ShowTop
  ShowLine

  printf "\n Select a job to show log file\n\n"

  ShowJobs starting failed running queued new completed
  ShowLine
  GetAnswer range

  if [ "${ANSWER}" != "x" ] ; then
    typeset _ALLANSWERS=$(range "${ANSWER}")
    for _EACH_ANSWER in ${_ALLANSWERS} ; do
      vi ${LOG_JOBDIR}/${JOB_ARRAY[${_EACH_ANSWER}]}.log
    done
  fi

#  create_file ${LOG_JOBDIR}/cache.$$ blank
#  for x in ${_FILES} ; do
#     #printf "%-50s" "$(basename ${x}) "
#     grep -v " ---" $x | tail -1  >> ${LOG_JOBDIR}/cache.$$
#  done
#  sort -n ${LOG_JOBDIR}/cache.$$
#  rm ${LOG_JOBDIR}/cache.$$
#  PressEnter

  WPCheckRC 0 "Leaving ${FUNCNAME}"
  MODULE=$(cdr "$MODULE")
}


ShowTasks()
{
  MODULE=$(push "$MODULE" "${FUNCNAME}")
  SCENE="Entering ${FUNCNAME}"
  WPCheckRC 0 "Entering ${FUNCNAME}"

  ShowTop
  ShowLine

  printf "\n Select a job to shows tasks\n\n"
  ShowJobs starting failed running queued new completed
  ShowLine
  GetAnswer range

  if [ "${ANSWER}" != "x" ] ; then
    typeset _ALLANSWERS=$(range "${ANSWER}")
    for _EACH_ANSWER in ${_ALLANSWERS} ; do
      [[ -r ${JOBDIR}/${JOB_STATE[${_EACH_ANSWER}]}/${JOB_ARRAY[${_EACH_ANSWER}]} ]] && ( grep "{WP_TASK}" ${JOBDIR}/${JOB_STATE[${_EACH_ANSWER}]}/${JOB_ARRAY[${_EACH_ANSWER}]} 2>/dev/null | cut -d"}" -f2- ) || echo " No Access to ${JOB_ARRAY[${_EACH_ANSWER}]}"
      PressEnter
    done
  fi

  WPCheckRC 0 "Leaving ${FUNCNAME}"
  MODULE=$(cdr "$MODULE")
}

EnterMOTD()
{
  MODULE=$(push "$MODULE" "${FUNCNAME}")
  SCENE="Entering ${FUNCNAME}"
  WPCheckRC 0 "Entering ${FUNCNAME}"

  # Function allows users to add own message of the day
  typeset local _MOTD

  create_file ${MOTD_FILE}
  printf "\n\n Enter MOTD : "
  read _MOTD
  [[ "${_MOTD}" != "" ]] && echo "+$(date +'%D %T') ${WHOAMI}: ${_MOTD}" >> ${MOTD_FILE} || echo "$(date +'%D %T') ${WHOAMI} cleared+" >> ${MOTD_FILE}

  WPCheckRC 0 "Leaving ${FUNCNAME}"
  MODULE=$(cdr "$MODULE")
}

ShowMOTD()
{
  MODULE=$(push "$MODULE" "${FUNCNAME}")
  SCENE="Entering ${FUNCNAME}"
  WPCheckRC 0 "Entering ${FUNCNAME}"

  # The functions shows the last line of the MOTD file
  if [ -r ${MOTD_FILE} ] ; then
    MOTD="$(tail -1 ${MOTD_FILE} | cut -d"+" -f2-)"
    [ "${MOTD}" != "" ] && echo " Message: ${MOTD}" && ShowLine
  fi

  WPCheckRC 0 "Leaving ${FUNCNAME}"
  MODULE=$(cdr "$MODULE")
}

FailureLog()
{
  MODULE=$(push "$MODULE" "${FUNCNAME}")
  SCENE="Entering ${FUNCNAME}"
  WPCheckRC 0 "Entering ${FUNCNAME}"

  typeset local JOB_FILE=$1


  # Stubbed to capture reason for resuming or starting jobs from a failed state or when deleting jobs
  printf "\n\n $(basename ${JOB_FILE})\n\n Enter a reason : "
  read _FAILURE_MESSAGE
  [[ "${_FAILURE_MESSAGE}" != "" ]] && echo "FAILURE MESSAGE+$(date +'%D %T') ${WHOAMI}+${_FAILURE_MESSAGE}" >> ${JOB_FILE}


  WPCheckRC 0 "Leaving ${FUNCNAME}"
  MODULE=$(cdr "$MODULE")
}

ProcessJob()
{
  # Function moves jobs from one user controlled state to another
  MODULE=$(push "$MODULE" "${FUNCNAME}")
  SCENE="Entering ${FUNCNAME}"
  WPCheckRC 0 "Entering ${FUNCNAME}"

  typeset ACTION=$1
  typeset TARGET

  ShowTop
  ShowLine

  printf "\n Select a job to ${ACTION}\n\n"
  case ${ACTION} in
    unqueue ) ShowJobs starting queued ; TARGET=${NEW_JOBDIR}     ;;
    start   ) ShowJobs failed new      ; TARGET=${QUEUED_JOBDIR}  ; Ck_Dispatcher ;;
    delete  ) ShowJobs failed new      ; TARGET=${DELETED_JOBDIR} ;;
    resume  ) ShowJobs failed          ; TARGET=${QUEUED_JOBDIR}  ; Ck_Dispatcher ;;
  esac

  ShowLine
  GetAnswer range

  # For the requested ACTION (passed in $1) move the available selected jobs to the selected state
  if [ "${ANSWER}" != "x" ] ; then
    typeset _ALLANSWERS=$(range "${ANSWER}")
    for _EACH_ANSWER in ${_ALLANSWERS} ; do


      # The answer must be less than or equal the number of results ( or less than the count)
      if [ ${_EACH_ANSWER} -lt $COUNT ] ; then
        typeset JOB_FILE=${JOBDIR}/${JOB_STATE[${_EACH_ANSWER}]}/${JOB_ARRAY[${_EACH_ANSWER}]}
        typeset JOB_LOGFILE=${TMPDIR}/$(basename ${JOB_ARRAY[${_EACH_ANSWER}]}).log

        # Check the user owns the job they try to start or resume and if not change the owner
        if [[ -r ${JOB_FILE} ]] ; then
          if [ "$(grep -wl "OWNER=${WHOAMI}" ${JOB_FILE})"  ] ; then
            # Job is ok
            # echo "Processing Job"
            :

          else
            printf "\n\n $(basename ${JOB_FILE}) WARNING\n You cannot start a job you do not own.\n\n"
            read -p " Do you wish to take ownership of this job (y/n)? " ANS
            if [[ "$ANS" = "y" ]]  ; then
              ChangeOwner ${JOB_FILE}
            else
              continue
            fi
          fi
        fi

        # AUDIT information and log failed and deleted jobs
        if [ "${JOB_STATE[${_EACH_ANSWER}]}" = "failed" ] || [ "${ACTION}" = "delete" ]; then
          FailureLog ${JOB_FILE}
        fi
        Audit ${JOB_FILE} ${ACTION}

        # If the file needs to be resumed then the RESUME point needs to be set in the file
        if [ ${ACTION} = "resume" ] ; then
          typeset RESUME_POINT=$(tail -10 ${JOB_LOGFILE} | grep ": Resume point:" | tail -1 | awk -F":" '{print $NF}')
          ChangeStart ${JOB_FILE} ${RESUME_POINT}
        else
          ChangeStart ${JOB_FILE} 0
        fi

      else

        WPWarning "Selection ${_EACH_ANSWER} out or range"
        sleep 3
        return 1

      fi

      touch ${JOB_FILE}
      mv ${JOB_FILE} ${TARGET}

    done
  fi

  WPCheckRC 0 "Leaving ${FUNCNAME}"
  MODULE=$(cdr "$MODULE")
}

ChangeOrder()
{
  # This function will change the order of a directories files. It can be used to change all files
  # or used to promote a subset of files leaving the outer set in the original order.
  MODULE=$(push "$MODULE" "${FUNCNAME}")
  SCENE="Entering ${FUNCNAME}"
  WPCheckRC 0 "Entering ${FUNCNAME}"

  ShowTop
  ShowLine

  ShowJobs queued
  printf "\n Select a job to promote or choose a new order\n\n"

  ShowLine
  GetAnswer
  ((COUNT-=1))
  typeset ORIG_ORDER=$(range 1-$COUNT)
  typeset NEW_ORIG=""
  if [ "${ANSWER}" != "x" ] ; then
    typeset _ALLANSWERS=$(range "${ANSWER}")
    for _EACH_ANSWER in $(echo ${_ALLANSWERS} | rev) ; do
      for _EACH_ORIG in $ORIG_ORDER; do
        if [[ ${_EACH_ORIG} != ${_EACH_ANSWER} ]] ; then
          NEW_ORIG="${NEW_ORIG} ${_EACH_ORIG}"
        fi
      done
      ORIG_ORDER="${NEW_ORIG}"
      NEW_ORIG=""
    done

    NEW_ORDER="${_ALLANSWERS} ${ORIG_ORDER}"
    for _TOUCH in ${NEW_ORDER} ; do
      touch ${JOBDIR}/${JOB_STATE[${_TOUCH}]}/${JOB_ARRAY[${_TOUCH}]}
      printf "."
    done
  fi

  WPCheckRC 0 "Leaving ${FUNCNAME}"
  MODULE=$(cdr "$MODULE")
}


GetJobID()
{
  # DESCRIPTION :  creates a job id for tracking runs and increments by one if required

  MODULE=$(push "$MODULE" "GetJobID")
  SCENE="Entering GetJobID"

  WPCheckRC 0 "Entering GetJobID"

  # Check JOBIDFILE variable is set
  if [ -z "${JOBIDFILE}" ] ; then
    WPError "JOBIDFILE Variable has not been set ... cannot continue"
  fi

  # Get the JOBID number if the file might contain it
  if [ -e "${JOBIDFILE}" ] && [ -r "${JOBIDFILE}" ]  ; then
    _JOBID=$(cat ${JOBIDFILE})
  else
    _JOBID=0
  fi

  touch "${JOBIDFILE}" > /dev/null 2>&1
  chmod 755 "${JOBIDFILE}" > /dev/null 2>&1

  # Set the new number
  if [ -w "${JOBIDFILE}" ] ; then
    (( _JOBID+=1 ))
    echo ${_JOBID} > ${JOBIDFILE}
  else
    WPError "Cannot increment the JOBIDFILE <${JOBIDFILE}>"
  fi

  WPCheckRC 0 "Leaving ${FUNCNAME}"
  MODULE=$(cdr "$MODULE")
}

AddTask()
{
  # This function adds the passed task to the job file.
  # It includes a redirect from /dev/null to allow for running from a none interactive session
  # It redirects output to the local dman valid log file
  #printf "Task_${TASKNUMBER}()\n{\n  \${WP_TASK} $1 < /dev/null >> \${LOG_FILE} \n  WPCheck_Status \$? ${TASKNUMBER}\n}\n\n" >> ${JOB_FILE}
  # $1 is set then create a counter extension for the log
  # Add the passed variable to a task function within the JOB_FILE
  MODULE=$(push "$MODULE" "${FUNCNAME}")
  SCENE="Entering ${FUNCNAME}"
  WPCheckRC 0 "Entering ${FUNCNAME}"

  if [ "${JOB_FILE}" = "/dev/null" ] ; then
    echo "# $1"
  else
    echo "Task_${TASKNUMBER}()" >> ${JOB_FILE}
    echo "{" >> ${JOB_FILE}
    echo "  echo \$(date +'%D %T') Task ${TASKNUMBER}/\${LAST} Started" >> ${JOB_FILE}
    echo "  \${WP_TASK} $1                 >> \${LOG_FILE} 2>&1" >> ${JOB_FILE}
    echo "  WPCheck_Status \$? ${TASKNUMBER}" >> ${JOB_FILE}
    echo "  echo \$(date +'%D %T') Task ${TASKNUMBER}/\${LAST} Completed" >> ${JOB_FILE}
    echo "}" >> ${JOB_FILE}
    echo " " >> ${JOB_FILE}
  fi

  # Increment the TASKNUMBER
  ((TASKNUMBER+=1))

  WPCheckRC 0 "Leaving ${FUNCNAME}"
  MODULE=$(cdr "$MODULE")
}

JobHeader()
{

  # This function initialises the self contained job file with variables gained from the framework
  # Tasks are added later from the plugins
  # Eventually when all tasks are added a JobFooter is appended which runs all the tasks
  MODULE=$(push "$MODULE" "${FUNCNAME}")
  SCENE="Entering ${FUNCNAME}"
  WPCheckRC 0 "Entering ${FUNCNAME}"


  JOB_NAME=$(basename ${JOB_FILE})
  cat >> ${JOB_FILE} << EOF
#!/bin/bash
# JIRAURL=${JIRADIR}/${JIRAID}
# Job created $(date +'%D %T') by ${WHOAMI}

# Tracking
# ========
RESUME=
OWNER=${WHOAMI}

# Job variables
# =============
#JOB_FILE=${JOB_FILE}
START_TIME="\$(date +%s)"
JOB_NAME=\$(basename \${0})
JOBDIR=${JOBDIR}
STARTING_JOBDIR=${STARTING_JOBDIR}
FAILED_JOBDIR=${FAILED_JOBDIR}
RUNNING_JOBDIR=${RUNNING_JOBDIR}
COMPLETED_JOBDIR=${COMPLETED_JOBDIR}
LOG_JOBDIR=${LOG_JOBDIR}
LOG_FILE=${LOG_JOBDIR}/\${JOB_NAME}.log
WP_TASK=""
RELEASE=${RELEASE}

# AUDIT
JIRAID=${JIRAID}
JOBID=${_JOBID}

# QUEUE MANAGER
LOCK_FILE=${LOCK_FILE}.${ENVIRONMENT}_$(echo ${ACTION} | cut -d- -f1)

ENVIRONMENT=${ENVIRONMENT}


mv \${STARTING_JOBDIR}/\${JOB_NAME} \${RUNNING_JOBDIR}/.
echo " " >>  \${LOG_FILE}
echo "\$(date ${DATEFORMAT}) Started Running" >> \${LOG_FILE}


WPCheck_Status()
{
  RC=\${1:-}
  TASK=\${2:-}
  if [ \${RC} -ne 0 ] ; then
    RESUME=\${TASK}
    echo "FAILED: Resume point:\${TASK}" >> \${LOG_FILE}
    mv \${RUNNING_JOBDIR}/\${JOB_NAME} \${FAILED_JOBDIR}/.

    # if no dependancies
    rm \${LOCK_FILE} > /dev/null 2>&1
    # fi

    exit 1
  fi
}


EOF

  WPCheckRC 0 "Leaving ${FUNCNAME}"
  MODULE=$(cdr "$MODULE")
}

JobFooter()
{
  # This funtion add the Footer to the Job file
  MODULE=$(push "$MODULE" "${FUNCNAME}")
  SCENE="Entering ${FUNCNAME}"
  WPCheckRC 0 "Entering ${FUNCNAME}"

  # If parserequest has finshed the current tasks for the current job apply the JobFooter
  ((TASKNUMBER-=1))
  printf "\nLAST=${TASKNUMBER}\n\n" >> ${JOB_FILE}
  cat >> ${JOB_FILE} << EOF

#
# Task control
START=\${RESUME:-1}
while [ \${START} -le \${LAST} ] ; do
  Task_\${START}
  ((START+=1))
done
#
# Count how many FAILURES there were
FAILURE_COUNT=\$(grep "^FAILURE MESSAGE+"  \${RUNNING_JOBDIR}/\${JOB_NAME} | wc -l 2>/dev/null)
if [ "\${FAILURE_COUNT}" -ge "1" ] ; then
  echo \$(date +'%D %T') \${LAST} Tasks completed with \$FAILURE_COUNT failures >> \${LOG_FILE}
else
  echo \$(date +'%D %T') \${LAST} Tasks completed successfully >> \${LOG_FILE}
fi
# If here then all tasks completed successfully
mv \${RUNNING_JOBDIR}/\${JOB_NAME} \${COMPLETED_JOBDIR}

# Stubbed for updating JIRA ticket or emailing user on successful deploy

# Remove LOCK
rm \${LOCK_FILE} > /dev/null 2>&1

# Log the completion of the job
FINISH_TIME=\$(date +%s)

echo \${START_TIME}, \${FINISH_TIME}, \$(date), \${JOB_NAME}, \${OWNER}, >> \${LOG_JOBDIR}/alljobs.csv
#
exit 0

# TEMPLATE USED
======================
EOF
  cat ${TMP_FILE} >> ${JOB_FILE}
  echo "======================" >> ${JOB_FILE}

  WPCheckRC 0 "Leaving ${FUNCNAME}"
  MODULE=$(cdr "$MODULE")
}

old_GetRequest()
{
  # This function repeatively gets lines of code from standard in until a full stop is provided on a line on its own
  # The lines that have a field delimeter on them are stored in a temporary files for further processing

  TMP_FILE=${BASEDIR}/var/tmp/${_JOBID}.${PID}
  typeset local _EACHLINE=""

  create_file ${TMP_FILE}  blank

  while [[ "${_EACHLINE}" != "." ]] ; do
    read _EACHLINE
    printf "${_EACHLINE}" | grep ":" | sed 's/  / /g' >> ${TMP_FILE}
  done
}

GetRequest()
{
  # This function works in two ways either:
  #  1 ) gets lines of a request from standard in until a full stop is provided on a line on its own
  #  2 ) gets lines of a request from a file
  # The lines that have a field delimeter on them are stored in a temporary files for further processing
  MODULE=$(push "$MODULE" "${FUNCNAME}")
  SCENE="Entering ${FUNCNAME}"
  WPCheckRC 0 "Entering ${FUNCNAME}"

  typeset local _FILE=${1:-}
  typeset local _EACHLINE=""

  # GLOBAL VARIABLE
  TMP_FILE=${TMPDIR}/${PROGNAME}.${PID}

  # Check the the dispatch daemon is running to process this request
  Ck_Dispatcher

  create_file ${TMP_FILE}  blank

  if [ ! -z "${_FILE}" ] ; then

    echo "$(date +'%D %T'): Processing file: $_FILE"

    while read _EACHLINE ; do
      echo ${_EACHLINE} | grep ":" >> ${TMP_FILE}
    done < ${_FILE}

  #cat ${TMP_FILE}

  else

    while [[ "${_EACHLINE}" != "." ]] ; do
      read _EACHLINE
      printf "${_EACHLINE}" | grep ":" | sed 's/  / /g' >> ${TMP_FILE}
    done

  fi

  WPCheckRC 0 "Leaving ${FUNCNAME}"
  MODULE=$(cdr "$MODULE")
}


Extract_Envs()
{
  # Common extractions of KEY PAIRS from the input file
  # Sometimes not all values will be passed but we need a few to default for job name consistancy

  # GLOBAL VARIABLES
  SYSTEM=$(grep -i "^ *SYSTEM *:"  ${TMP_FILE} | awk -F":" '{print $2}' | sed 's/[ ,]//g')
  [[ "${SYSTEM}" ]] || SYSTEM="NONE"

  RELEASE=$(grep -i "^ *release"  ${TMP_FILE} | awk -F":" '{print $2}' | sed 's/[ ,]//g')
  [[ "${RELEASE}" ]] || RELEASE="NONE"

  JIRAID=$(grep -i "^ *jira" ${TMP_FILE} | awk -F":" '{print $2}' | sed 's/[ ,]//g')
  [[ "${JIRAID}" ]]  || JIRAID="NONE"

  ENVIRONMENT_LIST=$(grep -i "^ *envir"  ${TMP_FILE} | awk -F":" '{print $2}' | sed 's/[&,]/ /g')
  [[ "${ENVIRONMENT_LIST}" ]] || ENVIRONMENT_LIST="NONE"

  ACTION_LIST=$(grep -i "^ *action"  ${TMP_FILE} | awk -F":" '{print $2}' | sed 's/[&,]//g')
  [[ "${ACTION_LIST}" ]] || ACTION_LIST=""

  TYPE=$(grep -i "^ *TYPE *ID *:" ${TMP_FILE} | awk -F":" '{print $2}' | sed 's/[ ,]//g')
  [[ "${TYPE}" ]]  || TYPE=""
}


ProcessRequest()
{
  MODULE=$(push "$MODULE" "${FUNCNAME}")
  SCENE="Entering ${FUNCNAME}"
  WPCheckRC 0 "Entering ${FUNCNAME}"

  # Assume a TMP_FILE is ready to be processed and process it
  GetJobID
  [[ ${FILE} ]] || printf "Extracting default key pairs from file ${TMP_FILE}\n"
  Extract_Envs
  [[ ${FILE} ]] || printf "Processing....\n"
  TASKNUMBER=0
  JOB_ID_COUNT=1
  JOB_FILE=/dev/null

  # Adding new code to process plugins
  # ==================================

  for ACTION in ${ACTION_LIST} ; do
    if [ "${ACTION}" != "" ] ; then

      for ENVIRONMENT in  ${ENVIRONMENT_LIST} ; do

        TASKNUMBER=0

        # Create a new blank job file in the new directory
        JOB_FILE=${NEW_JOBDIR}/${JIRAID}_${_JOBID}.${JOB_ID_COUNT}_${ENVIRONMENT}_${ACTION}_${RELEASE}
        create_file ${JOB_FILE} blank
        chmod 770 ${JOB_FILE}

        # Create a new blank related log file in the dman tmp directory
        JOB_LOG=${LOG_JOBDIR}/${JIRAID}_${_JOBID}.${JOB_ID_COUNT}_${ENVIRONMENT}_${ACTION}_${RELEASE}.log
        create_file ${JOB_LOG} blank
        echo "Job for ${JIRAID} created by ${WHOAMI} $(date +'%D %T')" >> ${JOB_LOG}
        JobHeader
        AddTask "date +%s ; echo PID:\$$"
        Plugin_${ACTION} >> ${LOG_FILE} 2>&1
        _RC=$?
        if [[ ${_RC} -eq 0 ]] ; then
          JobFooter
          Audit ${JOB_FILE} created
          [ "${ALLOW_START}" = "TRUE" ] && Audit ${JOB_FILE} "Auto queued" && ChangeOwner ${JOB_FILE} && mv ${JOB_FILE} ${QUEUED_JOBDIR}

        else
          JobFooter
          echo " " >> ${JOB_LOG}
          echo "####### Plugin_${ACTION} #######" >> ${JOB_LOG}
          echo "If no additional information appears above things to check for Plugin_${ACTION}" >> ${JOB_LOG}
          echo "  Does the plugin exist" >> ${JOB_LOG}
          echo "  Does the user or process have authorisation to run the plugin" >> ${JOB_LOG}
          echo "ERROR when creating job. Please check this log file." >> ${JOB_LOG}
          Audit ${JOB_FILE} created
          mv ${JOB_FILE} ${FAILED_JOBDIR}
          echo "ERROR in Plugin_${ACTION}" && PressEnter
        fi

        ((JOB_ID_COUNT+=1))
      done
    fi
  done
  rm ${TMP_FILE}

  WPCheckRC 0 "Leaving ${FUNCNAME}"
  MODULE=$(cdr "$MODULE")
}

AddJob()
{
  # This funtion allows a requester to add a request for parseing by the parserequest script
  MODULE=$(push "$MODULE" "${FUNCNAME}")
  SCENE="Entering ${FUNCNAME}"
  WPCheckRC 0 "Entering ${FUNCNAME}"

  InitPlugins
#  GetJobID

  #Show some example requests for demo/testing only
  printf "\n\n"
  if [ -r ${PLUGINDIR}/example_request.txt ] ; then
    ShowLine "-" "Example request"
    cat ${PLUGINDIR}/example_request.txt
  fi
  ShowLine
  printf "\n\n Enter request followed by a fullstop on a new line\".\":\n"

  GetRequest
  ProcessRequest

  WPCheckRC 0 "Leaving ${FUNCNAME}"
  MODULE=$(cdr "$MODULE")
}


ChangeOwner()
{
  MODULE=$(push "$MODULE" "${FUNCNAME}")
  SCENE="Entering ${FUNCNAME}"
  WPCheckRC 0 "Entering ${FUNCNAME}"

  typeset local JOB_FILE=$1
  typeset local JOB_LOGFILE=${LOG_JOBDIR}/$(basename $1).log

  # Make sure the JOB_FILE and it's JOB_LOGFILE are readable
  if [[ -r ${JOB_FILE}    ]] && [[ -r ${JOB_LOGFILE} ]] ; then

    # Check in the last 10 lines of the log file to find the previous owner

    #printf "Previously : "
    #grep "^OWNER=" ${JOB_FILE}


    # Change the resume point in the job to the new reume point
    if [[ $ALLOW_START ]] ; then
      cat ${JOB_FILE} | sed "s/^OWNER=.*/OWNER=${SELF_SERVICE_USER}/" > ${JOB_FILE}.$$.tmp
    else
      cat ${JOB_FILE} | sed "s/^OWNER=.*/OWNER=${WHOAMI}/" > ${JOB_FILE}.$$.tmp
    fi

    # Make sure that we still have values in the file in the tmp job before copying it back over the original
    [[ "$(grep OWNER=  ${JOB_FILE}.$$.tmp 2>/dev/null)" ]]  && cp ${JOB_FILE}.$$.tmp ${JOB_FILE} && rm ${JOB_FILE}.$$.tmp
    printf "Now set to : "
    grep "^OWNER=" ${JOB_FILE}
    WPMessage "${WHOAMI} accepted job ${JOB_FILE}" >> ${JOB_LOGFILE}

  else

    printf "\n\nError JOB_FILE or JOB_LOGFILE could not be read:\n\n"
    ls -l  ${JOB_FILE} ${JOB_LOGFILE}
    sleep 3
    return 1

  fi

  sleep 2


  WPCheckRC 0 "Leaving ${FUNCNAME}"
  MODULE=$(cdr "$MODULE")
}

ChangeStart()
{
  # This function will use the "FAILED: Resume point: n" found on the last line of the log file
  # to set a new "RESUME=" in the JOBFILE
  #  typeset local JOB_FILE=${JOBDIR}/${JOB_STATE}/$1
  MODULE=$(push "$MODULE" "${FUNCNAME}")
  SCENE="Entering ${FUNCNAME}"
  WPCheckRC 0 "Entering ${FUNCNAME}"

  typeset local JOB_FILE=${FAILED_JOBDIR}/$1
  typeset local JOB_FILE=$1
  typeset local JOB_LOGFILE=${LOG_JOBDIR}/$(basename ${1}).log
  typeset local RESUME_POINT=$2

  # Make sure the JOB_FILE and it's JOB_LOGFILE are readable
  if [[ -r ${JOB_FILE}    ]] && [[ -r ${JOB_LOGFILE} ]] ; then

    # Check in the last 10 lines of the log file to find the Resume point
   # typeset RESUME_POINT=$(tail -10 ${JOB_LOGFILE} | grep "FAILED: Resume point:" | tail -1 | cut -d: -f3)

    # Need to add a check to make sure a number is returned that is between the START and LAST task
    # more required checks etc

    # We may accidentally get a number with a space e.g " 2" type string rather than a numeric.
    # BASH doesnt allow us to declare numeric with typeset so lets do some maths to turn it into a true number
    (( RESUME_POINT+=0 ))

   # printf "Previously : "
#    grep "^RESUME=" ${JOB_FILE}

    # Change the resume point in the job to the new reume point
    cat ${JOB_FILE} | sed "s/^RESUME=.*/RESUME=${RESUME_POINT}/" > ${JOB_FILE}.$$.tmp

    # Make sure that we still have TASKS in the tmp job before copying it back over the original
    [[ "$(grep RESUME=  ${JOB_FILE}.$$.tmp)" ]]  && cp ${JOB_FILE}.$$.tmp ${JOB_FILE} && rm ${JOB_FILE}.$$.tmp
   # printf "Now set to : "
#    grep "^RESUME=" ${JOB_FILE}

  else

    printf "\n\nError JOB_FILE or JOB_LOGFILE could not be read:\n\n"
    ls -l  ${JOB_FILE} ${JOB_LOGFILE}
    sleep 3
    return 1

  fi

  sleep 1

  WPCheckRC 0 "Leaving ${FUNCNAME}"
  MODULE=$(cdr "$MODULE")
}

Audit()
{
  # This function is stubbed for further development
  echo $(date) ${WHOAMI} $2 >> ${1}
}

DoWhat()
{
  # This function takes a job location and allows actions to be run against it
  #   [0-9]*) DoWhat ${JOBDIR}/${JOB_STATE[${CHOICE}]}/${JOB_ARRAY[${CHOICE}]} ;;
  MODULE=$(push "$MODULE" "${FUNCNAME}")
  SCENE="Entering ${FUNCNAME}"
  WPCheckRC 0 "Entering ${FUNCNAME}"


  # Parameter 1 is expected to be the "state"
  typeset local JOB_STATE=$1
  typeset local JOB_FILE=${JOBDIR}/${JOB_STATE}/$2
  clear
  printf "\nJob File information:\n\n"
  grep "OWNER=" $JOB_FILE 2> /dev/null && printf "\n"
  ls -l $JOB_FILE
  ls -l ${LOG_JOBDIR}/$2.log
  ShowOptions ${JOB_STATE}
  read CHOICE
  case ${CHOICE} in
   e | E ) vi ${JOB_FILE}                ;;
   u | U ) Audit ${JOB_FILE} unqueue && mv ${JOB_FILE} ${NEW_JOBDIR} ;;
   s | S ) Audit ${JOB_FILE} start   && mv ${JOB_FILE} ${STARTING_JOBDIR} && Ck_Dispatcher ;;
   d | D ) Audit ${JOB_FILE} delete  && mv ${JOB_FILE} ${DELETED_JOBDIR} ;;
   r | R ) Audit ${JOB_FILE} resume
                typeset RESUME_POINT=$(tail -10 ${TMPDIR}/${2}.log | grep ": Resume point:" | tail -1 | awk -F":" '{print $NF}')
                ChangeStart ${JOB_FILE} ${RESUME_POINT}
                FailureLog ${JOB_FILE}
                mv ${JOB_FILE} ${QUEUED_JOBDIR}
                Ck_Dispatcher ;;

   f | F ) Audit ${JOB_FILE} fix_in_progress
                typeset RESUME_POINT=$(tail -10 ${TMPDIR}/${2}.log | grep ": Resume point:" | tail -1 | awk -F":" '{print $NF}')
                echo "FIP by ${USER} at $(date +%T): Resume Point:$RESUME_POINT" >> ${TMPDIR}/${2}.log ;;

   k | K ) Audit ${JOB_FILE} skiptask
                typeset RESUME_POINT=$(tail -10 ${TMPDIR}/${2}.log | grep ": Resume point:" | tail -1 | awk -F":" '{print $NF}')
                ((SKIP_POINT=RESUME_POINT+1))
                ChangeStart ${JOB_FILE} ${SKIP_POINT}
                FailureLog ${JOB_FILE}
                mv ${JOB_FILE} ${QUEUED_JOBDIR}
                Ck_Dispatcher
                printf "\nTASK ${RESUME_POINT} skipped by ${USER} at $(date +%T): Resume point:$SKIP_POINT" >> ${TMPDIR}/${2}.log ;;

   t | T ) grep "{WP_TASK}" ${JOB_FILE}  ; PressEnter ;;
   c | C ) ChangeOrder                   ;;
   l | L ) vi ${LOG_JOBDIR}/$2.log       ;;
   x | X | q | Q ) return ;;
  esac

  # After a vi the screen takes a moment to clear before the menu system comes back up so an additional clear command is required here
  clear

  WPCheckRC 0 "Leaving ${FUNCNAME}"
  MODULE=$(cdr "$MODULE")
}


Menu()
{
  MODULE=$(push "$MODULE" "${FUNCNAME}")
  SCENE="Entering ${FUNCNAME}"
  WPCheckRC 0 "Entering ${FUNCNAME}"


  SCREEN_WIDTH=$(tput cols)
  (( DISPLAY_WIDTH=$SCREEN_WIDTH - 2 - 12 - 5 - 8 - 15 - 10  - 10 ))
  ShowTop
  ShowLine "-" "Menu Test Only"
  typeset CHOICE=""
  COUNT=1
  for _EACH_LINE in $(wpget -pe linux | sort -u | sed 's/ /_/') ; do
        #     linenum | Jiraid | jobnum | env | plugin | release
    printf "%2s %12s" "${COUNT}" "$(echo ${_EACH_LINE})"
    printf "\n"

    # Load the JOB Array and JOB Location
    ENV_ARRAY[${COUNT}]=${_EACH_LINE}
    (( COUNT+=1 ))

  done

  printf "\n\n Enter Choice: "
  read -t 10 CHOICE
  case ${CHOICE} in
    [0-9]*) /deployment/space/psc/bin/showroles -e  $(echo ${ENV_ARRAY[${CHOICE}]} | sed 's/_/\.\*/') ;;
    x | X | q | Q ) break ;;
    * ) echo errrrror ;;
  esac


  PressEnter
  WPCheckRC 0 "Leaving ${FUNCNAME}"
  MODULE=$(cdr "$MODULE")
}


Manager()
{
  MODULE=$(push "$MODULE" "${FUNCNAME}")
  SCENE="Entering ${FUNCNAME}"
  WPCheckRC 0 "Entering ${FUNCNAME}"

  # Check dispatcher is running
  [[ "${DAEMON}" == "0" ]] || Ck_Dispatcher

  typeset CHOICE=""
  while : ; do

  [ -L ${DISPATCH_LOCK} ]  && LOCK_PID=$(ls -l ${DISPATCH_LOCK} | cut -d">" -f2- | awk -F"_" '{print $NF}' ) || LOCK_PID=0

    if [[ -f ${MAINTENANCE_FILE}  ]] ; then
      echo "${PROGNAME} is down for maintenance."
      echo "To reset ${PROGNAME} : rm ${MAINTENANCE_FILE}"
      exit 1
    fi

    ShowTop
    ShowJobs failed superseded starting running queued new completed
    ShowLine

    ShowMOTD

    ShowOptions

    read -t 10 CHOICE
    case ${CHOICE} in
      a | A ) Ck_Dispatcher ; AddJob ;;
      u | U ) ProcessJob unqueue     ;;
      s | S ) ProcessJob start       ;;
      d | D ) ProcessJob delete      ;;
      r | R ) ProcessJob resume      ;;
      t | T ) ShowTasks              ;;
      c | C ) ChangeOrder            ;;
      l | L ) ShowLog                ;;
      m | M ) EnterMOTD              ;;
      debug ) DEBUG=full             ;;
      maint ) create_file ${MAINTENANCE_FILE} blank ;;
      [0-9]*) DoWhat ${JOB_STATE[${CHOICE}]} ${JOB_ARRAY[${CHOICE}]} ;;
      x | X | q | Q ) break ;;
    esac
    #sleep 5
    CHOICE=""
    echo " "
    StartJobs ${WHOAMI}
  done

  #CheckQueuedJobs
  HouseKeeping

  WPCheckRC 0 "Leaving ${FUNCNAME}"
  MODULE=$(cdr "$MODULE")
}


# 19 yy
function_template()
{
  # AUTHOR : <name>
  # DATE CREATED: <date>
  # DESCRIPTION :  <it does this>
  #

  MODULE=$(push "$MODULE" "${FUNCNAME}")
  SCENE="Entering ${FUNCNAME}"
  WPCheckRC 0 "Entering ${FUNCNAME}"

  # COMMANDS GO HERE

  WPCheckRC 0 "Leaving ${FUNCNAME}"
  MODULE=$(cdr "$MODULE")
}


##########################################################################
view_change_env()
{
  set | more
  echo " "
  echo "Enter new Variable <or leave blank> and press <RETURN>"
  echo " "
  read ans
  echo "Setting.."
  eval $ans
  sleep 1
}
##########################################################################
create_file()
{
  typeset _FILE=$1
  typeset _BLANK=${2:-" "}
  touch $_FILE && chmod 664 $_FILE
  [ "${_BLANK}" = "blank" ] && > $_FILE
}
##########################################################################
PressEnter()
{
  printf "\n\n Press enter to continue: "
  read ANSWER
}
##########################################################################
GetAnswer()
{
  typeset _RANGE=${1:-""}
  printf "\n x. Exit\n\n"
  printf " Enter choice"
  [[ $_RANGE = "range" ]] && printf " (Range enabled: i.e 1-3,5) "
  printf ": "
  read ANSWER
  ANSWER=${ANSWER:-x}
}
##########################################################################
check_log()
{
# LIBRARY FUNCTION
# DO NOT MODIFY
#
# Add these parameters to your script before you use the debug library
#    PARAMETER=VALUE
#    PROGNAME=`basename $0`
#    LOG_FILE=/tmp/smecontrol.log # LOG File
#    LOGGING=file # Log level: full | none | interactive
#    DEBUG=off # Used with WPCheckRC: on | off | full

case $LOGGING in
  file|full)
    if [ "$LOG_FILE" ] ; then
      if [ ! -f $LOG_FILE ] ; then
        echo >$LOG_FILE "[${PROGNAME}] log file created on `date`"
        if [ $? -ne 0 ] ; then
          echo >&2 "$(date ${DATEFORMAT}) WARNING[${PROGNAME}] cannot create a new log file (${LOG_FILE})"
          LOGGING=interactive
          LOG_FILE=/dev/null
        fi
      else
        if [ ! -w $LOG_FILE ] ; then
          echo >&2 "$(date ${DATEFORMAT}) WARNING[${PROGNAME}] cannot write to the log file (${LOG_FILE})"
          LOGGING=interactive
          LOG_FILE=/dev/null
        fi
      fi
    else
      echo >&2 "$(date ${DATEFORMAT}) WARNING[${PROGNAME}] no log file defined"
      LOGGING=interactive
      LOG_FILE=/dev/null
    fi
    ;;
    none|interactive|off)
      LOG_FILE=/dev/null
    ;;
    *)
      echo >&2 "$(date ${DATEFORMAT}) WARNING[${PROGNAME}] \$LOGGING set to an illegal value (${LOGGING})"
      LOGGING=interactive
      LOG_FILE=/dev/null
  esac
# LIBRARY FUNCTION
# DO NOT MODIFY
}
##########################################################################
WPStatus()
{
# LIBRARY FUNCTION
# DO NOT MODIFY
# WPStatus returns information about the deployment
# to the specified location, normally to screen and a log file. The log file
# has the added information of a Date Time stamp
#

#
if [ $LOGGING != none -o $LOGGING != file ] ; then
  echo              "$(date ${DATEFORMAT}) STATUS[${PROGNAME}] Warning Count:${WARNINGCOUNT}"
fi
if [ $LOGGING != function ] ; then
  echo >> $LOG_FILE "$(date ${DATEFORMAT}) STATUS[${PROGNAME}] Warning Count:${WARNINGCOUNT}"
fi
# LIBRARY FUNCTION
# DO NOT MODIFY
}
##########################################################################
WPMessage()
{
# LIBRARY FUNCTION
# DO NOT MODIFY
# WPMessage expects a string or a quoted command and outputs the results
# to the specified location, normally to screen and a log file. The log file
# has the added information of a Date Time stamp
#
# Example:
# WPMessage "The program found these files"
# WPMessage "`ls`"
#
if [ $LOGGING != none -o $LOGGING != file ] ; then
  printf "%s %-25s" "$(date ${DATEFORMAT})" "INFORM[${PROGNAME}:${WARNINGCOUNT}]"
  printf " $1 \n"
fi
if [ $LOGGING != function ] ; then
  printf >> $LOG_FILE "$(date ${DATEFORMAT}) INFORM[${PROGNAME}:${WARNINGCOUNT}] $1\n"
fi
# LIBRARY FUNCTION
# DO NOT MODIFY
}
##########################################################################
WPError()
{
# LIBRARY FUNCTION
# DO NOT MODIFY
# WPError expects a string or a quoted command and outputs the results
# to the specified location, normally to screen and a log file. The log file
# has the added information of a Date Time stamp. If a second parameter is
# passed, it uses that for the exit status, or defaults to exit 1
#
# Example:
# WPError "The program did not find the files ${FILES}" 99
# WPError "`ls`"
#
  typeset END_TIME="$(date +%s)"
  (( TIMETAKEN= END_TIME - START_TIME ))
  WPMessage "Aborted after ${TIMETAKEN} seconds"
  WPMessage "Nested Module    : ${MODULE}"
  WPMessage "Scene            : ${SCENE}"
  WPMessage "Supporting Team  : ${SUPPORTINGTEAM}"

if [ $LOGGING != none -o $LOGGING != file ] ; then
  printf "%s %-25s" "$(date ${DATEFORMAT})" "ERROR[${PROGNAME}:${WARNINGCOUNT}]"
  printf " $1 \n"
  echo "#################################################  ERROR  #################################################"
fi

if [ $LOGGING != function ] ; then
  echo >> $LOG_FILE "$(date ${DATEFORMAT}) ERROR[${PROGNAME}] $1"
fi
set +u
if [ "$2" ] ; then
  exit $2
else
  exit 1
fi

# LIBRARY FUNCTION
# DO NOT MODIFY
}
##########################################################################
WPWarning()
{
# LIBRARY FUNCTION
# DO NOT MODIFY
# check_log expects a string or a quoted command and outputs the results
# to the specified location, normally to screen and a log file. The log file
# has the added information of a Date Time stamp
#
# Example:
# WPError "The program found these files"
# WPError "`ls`"
#
(( WARNINGCOUNT+=1 ))
if [ $LOGGING != none -o $LOGGING != file ] ; then
  printf "%s %-25s" "$(date ${DATEFORMAT})" "WARNING[${PROGNAME}:${WARNINGCOUNT}]"
  printf " $1 \n"
fi
if [ $LOGGING != function ] ; then
  echo >> $LOG_FILE "$(date ${DATEFORMAT}) WARNING[${PROGNAME}:${WARNINGCOUNT}] $1"
fi

# LIBRARY FUNCTION
# DO NOT MODIFY
}
##########################################################################
check_file()
{
# LIBRARY FUNCTION
# DO NOT MODIFY
#
# argument 1 = File to be checked
#
if [ `ls $1` ] ; then
  WPCheckRC 0 "Found $1"
else
  WPMessage "check_file($1) DID NOT FIND A FILE"
  exit
fi
}
##########################################################################
range()
{
# LIBRARY FUNCTION
# DO NOT MODIFY
#
# argument 1 = A range of numbers from which to create a list i.e "1-5,11-7,6"
#                                                             becomes 1 2 3 4 5 11 10 9 8 7 6
  typeset INPUT=$(echo $1 | tr -s "," " " )

  for _EACH_ITEM in ${INPUT} ; do
    if [ $(echo ${_EACH_ITEM} | grep "-") ] ; then
      typeset PART1=$(echo ${_EACH_ITEM} | cut -d "-" -f1)
      typeset PART2=$(echo ${_EACH_ITEM} | cut -d "-" -f2)
      if [ ${PART1} -lt ${PART2} ] ; then
        while [[ ${PART1} -le ${PART2} ]] ; do
          printf "${PART1} "
          ((PART1+=1))
        done
      else
        while [[ ${PART1} -ge ${PART2} ]] ; do
          printf "${PART1} "
          ((PART1-=1))
        done
      fi
    else
      printf "${_EACH_ITEM} "
    fi
  done
}
##########################################################################
push()
{
# LIBRARY FUNCTION
# DO NOT MODIFY
#
# argument 1 = Stack list
# argument 2 = Item to add
# return     = new stack
#
echo "$1 $2"
}
##########################################################################
pop()
{
# LIBRARY FUNCTION
# DO NOT MODIFY
#
# argument 1 = Stack list
# return     = new stack
#
echo $1 | awk '{print $NF}'
}
##########################################################################
cdr()
{
# LIBRARY FUNCTION
# DO NOT MODIFY
#
# argument 1 = Stack list
# return     = new stack
#
echo $1 | awk '{for ( i = 1; i < NF; i++) print $i }'
}
##########################################################################
WPCheckRC()
{
# LIBRARY FUNCTION
# DO NOT MODIFY
#
# argument 1 = status to be checked
# argument 2 = command name
# argument 3 = NOEXIT flag
#
# WPCheckRC can be used in 3 ways.
# Either to provide useful information during the execution of a script
# when debugging is turned on (DEBUG=on or DEBUG=full).
# WPCheckRC 0 "got here"
#
# to provide error checking and break points
# cp $A $B
# WPCheckRC $? "Copying File" (if copying fails the script will exit)
#
# ls $A
# WPCheckRC $? "Checking for file" NOEXIT
#
# or an undocumented feature for use during development to run internal
# commands like changing environment variable in DEBUG=full mode.
# CHECK DEBUG and WPMessage
# CHECK FOR ARGUMENTS
# ===================
_NOEXIT=${3:-" "}
if [ $1 -ne 0 ] ; then
  if [ "$3" != "NOEXIT" ] ; then
  WPError "$2 - FAILED with status code $1 /n/n#######################" $1
    exit $1
  else
    WPWarning "$2 - FAILED with status code $1 /n/n#######NOEXIT##########"
    return $1
  fi
else
  if [ ${DEBUG} != "off" ] ; then
    WPMessage "[DEBUG] The passed message for debug is ($2)"
    if [ $DEBUG = "full" ] ; then
      echo " "
      echo "             -- Press <return> or q to quit -- "
      read ans
      if [ "$ans" = "q" ] ; then
        exit 0
      else
        while [ "${ans}" != "" ] ; do
          if [ "$ans" != "" ] ; then
            # Comment this out for productions envs !!!!!!!!!!!!!!!!==
            WPWarning "${WHOAMI} command: >${ans}<"
            eval $ans
            read ans
                        # ======================================!!!!!!!!!!!!!!!!==
          fi
        done
      fi
    fi
  fi
  SUPPORTINGTEAM=${DEPLOYMENTTEAM}
  return 0
fi
# LIBRARY FUNCTION
# DO NOT MODIFY
}
##########################################################################
log_trap()
{
# LIBRARY FUNCTION
# DO NOT MODIFY
  WPWarning "$1"
  WPStatus
  WPError "ABORTED"
  echo " "
  exit 1
}
trap "log_trap \"TERMINATED: User probably logged out\"" 1
trap "log_trap \"TERMINATED: User probably ctrl-c\"" 2
trap "log_trap \"TERMINATED: Illegal Instruction\"" 4
trap "log_trap \"TERMINATED: Probably via kill\"" 15
#trap "log_trap \"\n\nTERMINATED: ERR\"" ERR
# LIBRARY FUNCTION
# DO NOT MODIFY
##########################################################################
initializeANSI()
{
  esc="

lackf="${esc}[30m";   redf="${esc}[31m";    greenf="${esc}[32m"
  yellowf="${esc}[33m"   bluef="${esc}[34m";   purplef="${esc}[35m"
  cyanf="${esc}[36m";    whitef="${esc}[37m"

  blackb="${esc}[40m";   redb="${esc}[41m";    greenb="${esc}[42m"
  yellowb="${esc}[43m"   blueb="${esc}[44m";   purpleb="${esc}[45m"
  cyanb="${esc}[46m";    whiteb="${esc}[47m"

  boldon="${esc}[1m";    boldoff="${esc}[22m"
  italicson="${esc}[3m"; italicsoff="${esc}[23m"
  ulon="${esc}[4m";      uloff="${esc}[24m"
  invon="${esc}[7m";     invoff="${esc}[27m"

  reset="${esc}[0m"
}
initializeANSI                                                          # Set up screen colours
# LIBRARY FUNCTION
# DO NOT MODIFY
##########################################################################

#MAIN

MODULE="main"

CheckSetUp
# Stubbed:   CheckAuthorisation

[[ "${DAEMON}" -eq "1" ]] && Dispatcher_Daemon && exit 0

InitPlugins

[[ ${FILE} ]] && GetRequest $FILE && ProcessRequest && exit 0

[[ ! ${FILE} ]] && Manager

exit

